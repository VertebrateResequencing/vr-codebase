=head1 NAME

VertRes::Pipelines::TrackQC_Bam - pipeline for QC of bam files

=head1 SYNOPSIS

See /lustre/scratch102/conf/pipeline.conf and /lustre/scratch102/conf/qc-g1k-meta.conf
for an example.

=cut

package VertRes::Pipelines::TrackQC_Bam;
use base qw(VertRes::Pipeline);

use strict;
use warnings;
use VertRes::LSF;
use VertRes::Utils::GTypeCheck;
use VertRes::Utils::GTypeCheckGLF;
use VRTrack::VRTrack;
use VRTrack::Lane;
use VRTrack::Mapstats;
use VertRes::Parser::bamcheck;
use VertRes::Parser::bam;
use VertRes::Parser::dict;
use Scalar::Util qw(looks_like_number);
use Utils;

our @actions =
(
    # Takes care of merging of the (possibly) multiple bam files
    {
        'name'     => 'rename_and_merge',
        'action'   => \&rename_and_merge,
        'requires' => \&rename_and_merge_requires, 
        'provides' => \&rename_and_merge_provides,
    },

    # Check sanity, namely the reference sequence
    {
        'name'     => 'check_sanity',
        'action'   => \&check_sanity,
        'requires' => \&check_sanity_requires, 
        'provides' => \&check_sanity_provides,
    },

    # Runs glf to check the genotype.
    {
        'name'     => 'check_genotype',
        'action'   => \&check_genotype,
        'requires' => \&check_genotype_requires, 
        'provides' => \&check_genotype_provides,
    },

    # Creates some QC graphs and generate some statistics.
    {
        'name'     => 'stats_and_graphs',
        'action'   => \&stats_and_graphs,
        'requires' => \&stats_and_graphs_requires, 
        'provides' => \&stats_and_graphs_provides,
    },

    # Checks the generated stats and attempts to auto pass or fail the lane.
    {
        'name'     => 'auto_qc',
        'action'   => \&auto_qc,
        'requires' => \&auto_qc_requires, 
        'provides' => \&auto_qc_provides,
    },

    # Writes the QC status to the tracking database.
    {
        'name'     => 'update_db',
        'action'   => \&update_db,
        'requires' => \&update_db_requires, 
        'provides' => \&update_db_provides,
    },
);

our $options = 
{
    # Executables
    'bamcheck'        => 'bamcheck -q 20',
    'blat'            => '/software/pubseq/bin/blat',
    'gcdepth_R'       => '/software/vertres/bin-external/gcdepth.R',
    'glf'             => 'glf',
    'mapviewdepth'    => 'mapviewdepth_sam',
    'samtools'        => 'samtools',
    'clean_fastqs'    => 0,

    'adapters'        => '/software/pathogen/projects/protocols/ext/solexa-adapters.fasta',
    'bsub_opts'       => "-q normal -M5000 -R 'select[type==X86_64] select[mem>5000] rusage[mem=5000]'",
    'bsub_opts_merge' => "-q normal -M5000 -R 'select[type==X86_64] select[mem>5000] rusage[mem=5000] rusage[thouio=5]'",
    'gc_depth_bin'    => 20000,
    'gtype_confidence'=> 5.0,
    'mapstat_id'      => 'mapstat_id.txt',
    'sample_dir'      => 'qc-sample',
    'stats'           => '_stats',
    'stats_detailed'  => '_detailed-stats.txt',
    'chr_regex'       => '^(?:\d+|X|Y)$',
    'do_samtools_rmdup' => 0,

    auto_qc =>
    {
        gtype_regex  => qr/^confirmed$/,
        mapped_bases => 80,
        error_rate   => 0.02,
        inserts_peak_win     => 25,
        inserts_within_peak  => 80,
        max_ins_to_del_ratio => 1.0,
    },
};


# --------- OO stuff --------------

=head2 new

        Example    : my $qc = VertRes::Pipelines::TrackQC_Bam->new( 'sample_dir'=>'dir', 'sample_size'=>1e6 );
        Options    : See Pipeline.pm for general options.

                    # Executables
                    bamcheck        .. bamcheck executable with parameters
                    blat            .. blat executable
                    gcdepth_R       .. gcdepth R script
                    glf             .. glf executable
                    mapviewdepth    .. mapviewdepth executable
                    samtools        .. samtools executable

                    # Options specific to TrackQC
                    adapters        .. the location of .fa with adapter sequences
                    assembly        .. e.g. NCBI36
                    bsub_opts       .. LSF bsub options for jobs
                    bsub_opts_merge .. LSF bsub options for the rename_and_merge task (thouio=50)
                    bwa_ref         .. the prefix to reference files, as required by bwa
                    clean_fastqs    .. If set, .fastq files will be deleted as the last step in update_db
                    do_samtools_rmdup .. If set, pipes the bam through samtools rmdup to get stats without duplicates
                    fa_ref          .. the reference sequence in fasta format
                    fai_ref         .. the index to fa_ref generated by samtools faidx
                    gc_depth_bin    .. the bin size for the gc-depth graph
                    gtype_confidence.. the minimum expected glf likelihood ratio
                    mapstat_id      .. if the file exists, use the id inside for the vrtrack mapstat
                    paired          .. is the lane from paired-end sequencing?
                    snps            .. genotype file generated by hapmap2bin from glftools
                    sample_dir      .. where to put subsamples
                    stats_ref       .. e.g. /path/to/NCBI36.stats
                    auto_qc         .. hash with the keys gtype_regex,mapped_bases,error_rate,inserts_peak_win,inserts_within_peak,max_ins_to_del_ratio

=cut

sub new 
{
    my ($class, @args) = @_;
    my $self = $class->SUPER::new(%$options,'actions'=>\@actions,@args);
    $self->write_logs(1);

    if ( !$$self{gcdepth_R} ) { $self->throw("Missing the option gcdepth_R.\n"); }
    if ( !$$self{glf} ) { $self->throw("Missing the option glf.\n"); }
    if ( !$$self{mapviewdepth} ) { $self->throw("Missing the option mapviewdepth.\n"); }
    if ( !$$self{samtools} ) { $self->throw("Missing the option samtools.\n"); }
    if ( !$$self{fa_ref} ) { $self->throw("Missing the option fa_ref.\n"); }
    if ( !$$self{fai_ref} ) { $self->throw("Missing the option fai_ref.\n"); }
    if ( !$$self{gc_depth_bin} ) { $self->throw("Missing the option gc_depth_bin.\n"); }
    if ( !$$self{gtype_confidence} ) { $self->throw("Missing the option gtype_confidence.\n"); }
    if ( !$$self{sample_dir} ) { $self->throw("Missing the option sample_dir.\n"); }

    return $self;
}


=head2 clean

        Description : If mrProper option is set, the entire QC directory will be deleted.
        Returntype  : None

=cut

sub clean
{
    my ($self) = @_;

    $self->SUPER::clean();

    if ( !$$self{'lane_path'} ) { $self->throw("Missing parameter: the lane to be cleaned.\n"); }
    if ( !$$self{'sample_dir'} ) { $self->throw("Missing parameter: the sample_dir to be cleaned.\n"); }

    if ( $$self{'mrProper'} ) 
    { 
        my $qc_dir = qq[$$self{'lane_path'}/$$self{'sample_dir'}];
        $self->debug("rm -rf $qc_dir $qc_dir*\n");
        Utils::CMD(qq[rm -rf $qc_dir $qc_dir.*]);
        return;
    }
}


=head2 lane_info

        Arg[1]      : field name: one of genotype,gtype_confidence
        Description : Temporary replacement of HierarchyUtilities::lane_info. Most of the data are now passed
                        to pipeline from a config file, including gender specific data. What's left are minor
                        things - basename of the lane and expected genotype name and confidence. Time will show
                        where to put this.
        Returntype  : field value

=cut

sub lane_info
{
    my ($self,$field) = @_;

    my $sample = $$self{sample};

    # By default, the genotype is named as sample. The exceptions should be listed
    #   in the known_gtypes hash.
    my $gtype = $sample;
    if ( exists($$self{known_gtypes}) &&  exists($$self{known_gtypes}{$sample}) )
    {
        $gtype = $$self{known_gtypes}{$sample};
    }
    if ( $field eq 'genotype' ) { return $gtype; }

    if ( $field eq 'gtype_confidence' )
    {
        if ( exists($$self{gtype_confidence}) && ref($$self{gtype_confidence}) eq 'HASH' )
        {
            if ( exists($$self{gtype_confidence}{$gtype}) ) { return $$self{gtype_confidence}{$gtype}; }
        }
        elsif ( exists($$self{gtype_confidence}) )
        {
            return $$self{gtype_confidence};
        }

        # If we are here, either there is no gtype_confidence field or it is a hash and does not
        #   contain the key $gtype. In such a case, return unrealisticly high value.
        return 1000;
    }

    $self->throw("Unknown field [$field] to lane_info\n");
}



#---------- rename_and_merge ---------------------

# Requires nothing
sub rename_and_merge_requires
{
    my ($self) = @_;
    my @requires = ();
    return \@requires;
}

sub rename_and_merge_provides
{
    my ($self) = @_;
    my @provides = ("$$self{sample_dir}/$$self{lane}.bam");
    return \@provides;
}

sub rename_and_merge
{
    my ($self,$lane_path,$lock_file) = @_;

    my $samtools = $$self{samtools};
    my $name     = $$self{lane};
    my @files    = glob("$lane_path/*.bam");
    if ( !scalar @files ) { $self->throw("No BAM files in [$lane_path]?"); }

    # First try to use the bam recommended by VertRes::Utils::Hierarchy->lane_bams. For this,
    #   db, slx_mapper, 454_mapper and assembly_name must be given
    if ( exists($$self{db}) && exists($$self{slx_mapper}) && exists($$self{'454_mapper'}) && exists($$self{assembly_name}) )
    {
        my $vrtrack = VRTrack::VRTrack->new($$self{db}) or $self->throw("Could not connect to the database: ",join(',',%{$$self{db}}),"\n");
        my $hu = VertRes::Utils::Hierarchy->new();
        my @bams;
        eval { 
            @bams = $hu->lane_bams($lane_path,vrtrack=>$vrtrack,slx_mapper=>$$self{slx_mapper},'454_mapper'=>$$self{'454_mapper'},assembly_name=>$$self{assembly_name});
        };
        if ( @bams && -e "$lane_path/$bams[0]" ) { @files = @bams; }
    }

    # The bam files produced by the mapping pipeline are named as
    #   MAPSTAT_ID.pe.raw.sorted.bam. In such a case, use the mapstat id to
    #   update the mapstats, so that the mapper and assembly information is
    #   preserved.
    my %mapstat_ids;
    for my $file (@files)
    {
        if ( $file=~m{(\d+)\.[ps]e\.recal\.sorted\.bam} ) { push @{$mapstat_ids{$1}},$file; }
        elsif ( $file=~m{(\d+)\.[ps]e\.raw\.sorted\.bam} ) { push @{$mapstat_ids{$1}},$file; }
    }

    # Reuse existing qc-sample.$mapstat_id directory
    my $work_dir = "$lane_path/$$self{sample_dir}";
    my $mapstat_id;
    if ( scalar keys %mapstat_ids )
    {
        my @ids = sort { $b<=>$a } keys %mapstat_ids;
        if ( ! scalar @ids ) { $self->throw("No bam files in $lane_path?"); }

        # Take the bam file with the highest mapstat_id
        $mapstat_id = $ids[0];

        if ( ! -e $work_dir && -e "$lane_path/$$self{sample_dir}.$mapstat_id" )
        {
            Utils::relative_symlink("$lane_path/$$self{sample_dir}.$mapstat_id",$work_dir);
        }
    }
    Utils::create_dir($work_dir) unless -e $work_dir;

    # We can also get BAM files from iRODS. In that case the naming convention is different.
    #   If there is one BAM file only, proceed, otherwise throw an error.
    if ( ! scalar keys %mapstat_ids ) 
    {
        if ( scalar @files==1 )
        {
            Utils::relative_symlink("$files[0]","$work_dir/$name.bam") unless -e "$work_dir/$name.bam";
            return $$self{'Yes'};
        }
    }

    # Remember the id for later
    open(my $fh,'>',"$work_dir/$$self{mapstat_id}") or $self->throw("$work_dir/$$self{mapstat_id}: $!");
    print $fh "$mapstat_id\n";
    close($fh);

    # There can be multiple files with this id, (paired and single end reads)
    @files = @{$mapstat_ids{$mapstat_id}};
    if ( scalar @files == 1 )
    {
        Utils::relative_symlink("$files[0]","$work_dir/$name.bam") unless -e "$work_dir/$name.bam";
        return $$self{'Yes'};
    }

    # If there are multiple bam files with the same mapstat_id, merge them
    my $bams = join(' ',@files);
    my $umask    = $self->umask_str;
    open($fh,'>', "$work_dir/_merge.pl") or Utils::error("$work_dir/_merge.pl: $!");
    print $fh qq[
use Utils;
$umask
Utils::CMD("$samtools merge x$name.bam $bams");
if ( ! -s "x$name.bam" ) { Utils::error("The command ended with an error:\\n\\t$samtools merge x$name.bam ../$bams\\n"); }
rename("x$name.bam","$name.bam") or Utils::error("rename x$name.bam $name.bam: \$!");
];
    close($fh);

    VertRes::LSF::run($lock_file,$work_dir,"_${name}_merge",{bsub_opts=>$$self{bsub_opts_merge}}, q{perl -w _merge.pl});
    return $$self{'No'};
}



#----------- check_sanity ---------------------

sub check_sanity_requires
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my @requires = ("$sample_dir/$$self{lane}.bam");
    return \@requires;
}

sub check_sanity_provides
{
    my ($self) = @_;
    return exists($$self{dict_ref}) ? ['_check_sanity.done'] : [];
}

sub check_sanity
{
    my ($self,$lane_path,$lock_file) = @_;

    if ( !$$self{dict_ref} ) { $self->throw("FIXME: this should not happen"); }

    # Get all reference sequences and their MD5
    my $dict = VertRes::Parser::dict->new(file=>$$self{dict_ref});
    my $result_holder = $dict->result_holder();
    my %seqs;
    while ($dict->next_result()) 
    {
        my $seq = $result_holder->{SN};
        my $md5 = $result_holder->{M5};
        $seqs{$seq} = $md5;
    }
    undef $dict;

    my $bam = VertRes::Parser::bam->new(file=>"$$self{lane_path}/$$self{sample_dir}/$$self{lane}.bam");
    my %bam_seq_info = $bam->sequence_info();
    my @missing  = ();
    my @mismatch = ();
    while (my ($seq,$info) = each %bam_seq_info)
    {
        if ( !exists($seqs{$seq}) ) { push @missing, $seq; next; }
        if ( $seqs{$seq} ne $$info{M5} ) { push @mismatch, $seq; next; }
    }
    undef $bam;

    my $err_msg;
    if ( @missing ) { $err_msg .= sprintf("\t%d sequence name(s) are not present in the dictionary: %s\n", scalar @missing, join(',',@missing)); }
    if ( @mismatch ) { $err_msg .= sprintf("\t%d sequence name(s) have different MD5 sum: %s\n", scalar @mismatch, join(',',@mismatch)); }
    if ( $err_msg )
    {
        $self->throw("The bam file does not match the reference.\n" 
            . "Sanity check failed: $$self{lane_path}/$$self{sample_dir}/$$self{lane}.bam\n"
            . "The ref dict was: $$self{dict_ref}\n"
            . $err_msg 
            );
    }

    `touch $$self{lane_path}/$$self{sample_dir}/_check_sanity.done`;

    return $$self{'Yes'};
}


#----------- check_genotype ---------------------

sub check_genotype_requires
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my @requires = ("$sample_dir/$$self{lane}.bam");
    return \@requires;
}

sub check_genotype_provides
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my @provides = ("$sample_dir/$$self{lane}.gtype");
    return \@provides;
}

sub check_genotype
{
    my ($self,$lane_path,$lock_file) = @_;

    # Skip Genotype Check
    if(exists $$self{'skip_genotype'} && $$self{'skip_genotype'})
    { $self->debug("Skipping genotype check.\n"); return $$self{'Yes'}; }

    if ( !$$self{snps} ) { $self->throw("Missing the option snps.\n"); }

    my $name = $$self{lane};

    my $options = {};
    $$options{'bam'}           = "$lane_path/$$self{'sample_dir'}/$name.bam";
    $$options{'bsub_opts'}     = $$self{'bsub_opts'};
    $$options{'fa_ref'}        = $$self{'fa_ref'};
    $$options{'glf'}           = $$self{'glf'};
    $$options{'snps'}          = $$self{'snps'};
    $$options{'samtools'}      = exists($$self{samtools_glf}) ? $$self{samtools_glf} : $$self{'samtools'};
    $$options{'genotype'}      = $self->lane_info('genotype');
    $$options{'min_glf_ratio'} = $self->lane_info('gtype_confidence');
    $$options{'prefix'}        = $$self{'prefix'};
    $$options{'lock_file'}     = $lock_file;

    if (exists $self->{snp_sites}) {
        $options->{snp_sites} = $self->{snp_sites};
    }

	my $glf_bcf = exists($$self{glf_or_bcf}) ? $$self{glf_or_bcf} : 'bcf' ;
    my $gtc = $glf_bcf eq 'glf' ? VertRes::Utils::GTypeCheckGLF->new(%$options) : VertRes::Utils::GTypeCheck->new(%$options);
    $gtc->check_genotype();

    return $$self{'No'};
}


#----------- stats_and_graphs ---------------------

sub stats_and_graphs_requires
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my @requires = ("$sample_dir/$$self{lane}.bam");
    return \@requires;
}

sub stats_and_graphs_provides
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my @provides = ("$sample_dir/_graphs.done");
    return \@provides;
}

sub stats_and_graphs
{
    my ($self,$lane_path,$lock_file) = @_;

    my $sample_dir = $$self{'sample_dir'};
    my $lane  = $$self{lane};
    my $stats_ref = exists($$self{stats_ref}) ? $$self{stats_ref} : '';
    my $class = (caller(0))[0];  # In case we are called from a inherited object
	my $umask    = $self->umask_str;
    
    my $name = $$self{lane};
    if ( !$$self{db} ) { $self->throw("Expected the db key.\n"); }
    my $vrtrack     = VRTrack::VRTrack->new($$self{db}) or $self->throw("Could not connect to the database: ",join(',',%{$$self{db}}),"\n");
    my $vrlane      = VRTrack::Lane->new_by_hierarchy_name($vrtrack,$name) or $self->throw("No such lane in the DB: [$name]\n");
    my $insert_size = (VRTrack::Library->new($vrtrack, $vrlane->library_id())->insert_size() )*3 || 8000;

    # Dynamic script to be run by LSF.
    open(my $fh, '>', "$lane_path/$sample_dir/_graphs.pl") or Utils::error("$lane_path/$sample_dir/_graphs.pl: $!");
    print $fh 
qq[
use VertRes::Pipelines::TrackQC_Bam;
$umask

my \%params = 
(
    'gc_depth_bin' => q[$$self{'gc_depth_bin'}],
    'mapviewdepth' => q[$$self{'mapviewdepth'}],
    'samtools'     => q[$$self{'samtools'}],
    'gcdepth_R'    => q[$$self{'gcdepth_R'}],
    'lane_path'    => q[$lane_path],
    'lane'         => q[$$self{lane}],
    'sample_dir'   => q[$$self{'sample_dir'}],
    'fa_ref'       => q[$$self{fa_ref}],
    'fai_ref'      => q[$$self{fai_ref}],
    'stats_ref'    => q[$stats_ref],
    'chr_regex'    => q[$$self{chr_regex}],
    'bamcheck'     => q[$$self{bamcheck}],
    'do_samtools_rmdup' => q[$$self{do_samtools_rmdup}]
);

my \$qc = VertRes::Pipelines::TrackQC_Bam->new(\%params);
\$qc->run_graphs(\$params{lane_path}, $insert_size);
];
    close $fh;

    VertRes::LSF::run($lock_file,"$lane_path/$sample_dir","_${lane}_graphs", $self, qq{perl -w _graphs.pl});
    return $$self{'No'};
}


sub run_graphs
{
    my ($self,$lane_path,$insert_size) = @_;

    use Graphs;
    use SamTools;
    use Utils;

    # Set the variables
    my $sample_dir   = $$self{'sample_dir'};
    my $name         = $$self{lane};
    my $outdir       = "$lane_path/$sample_dir/";
    my $bam_file     = "$outdir/$name.bam";

    my $samtools     = $$self{'samtools'};
    my $mapview      = $$self{'mapviewdepth'};
    my $refseq       = $$self{'fa_ref'};
    my $fai_ref      = $$self{'fai_ref'};
    my $gc_depth_bin = $$self{'gc_depth_bin'};
    my $bindepth     = "$outdir/gc-depth.bindepth";
    my $gcdepth_R    = $$self{'gcdepth_R'};
    my $stats_file   = "$outdir/$$self{stats_detailed}";
    
    # Run bamcheck even if bamcheck output already exists. The import pipeline does not have
    #   the reference sequence and bamcheck only approximates the GC depth graph. It takes 8 minutes
    #   to run 17GB file, no big overhead.
    Utils::CMD(qq[$$self{bamcheck} -r $refseq -i $insert_size $bam_file > $bam_file.bc.tmp]);
    rename("$bam_file.bc.tmp","$bam_file.bc") or $self->throw("rename $bam_file.bc.tmp $bam_file.bc: $!");
    if ( ! -e "$bam_file.rmdup.bc" )
    {
        my $cmd = $$self{do_samtools_rmdup} ? qq[samtools rmdup $bam_file - | $$self{bamcheck}] : qq[$$self{bamcheck} -d $bam_file];
        Utils::CMD(qq[$cmd > $bam_file.rmdup.bc.tmp]);
        rename("$bam_file.rmdup.bc.tmp","$bam_file.rmdup.bc") or $self->throw("rename $bam_file.rmdup.bc.tmp $bam_file.rmdup.bc: $!");
    }
    my $bc = VertRes::Parser::bamcheck->new(file=>"$bam_file.bc");
    #To stop some lanes form repeatedly failing add a check to prevent graphs/stats being calculated if the bam file is empty (no sequences or reads) or if there are reads, but none are mapped.
    if ( $bc->get('sequences') > 0 && $bc->get('total_length') > 0 && $bc->get('reads_mapped') > 0 )
    {
    	# Plot bamcheck graphs
    	my $stats_ref = $$self{stats_ref} ? "-r $$self{stats_ref}" : '';
    	
    	if(! (-e "$refseq.gc") )
    	{
    	  Utils::CMD("plot-bamcheck -s $refseq > $refseq.gc");
  	  }
    	Utils::CMD("plot-bamcheck -p $outdir/ -r $refseq.gc  $bam_file.bc");

    	# Get and report the stats
    	report_detailed_stats($lane_path,$bam_file,$stats_file);
    }
    `touch $outdir/_graphs.done`;
}


sub report_detailed_stats
{
    my ($lane_path,$bamfile,$outfile) = @_;

    my $bc = VertRes::Parser::bamcheck->new(file=>"$bamfile.bc");
    my $reads_total    = $bc->get('sequences');
    my $reads_mapped   = $bc->get('reads_mapped');
    my $reads_paired   = $bc->get('reads_paired');
    my $bases_total    = $bc->get('total_length');
    my $bases_trimmed  = $bc->get('bases_trimmed');
    my $bases_mapped   = $bc->get('bases_mapped');
    my $bases_mapped_c = $bc->get('bases_mapped_cigar');
    my $error_rate     = $bc->get('error_rate');
    my $avg_isize      = $bc->get('avg_insert_size');
    my $sd_insert_size = $bc->get('sd_insert_size');

    $bc = VertRes::Parser::bamcheck->new(file=>"$bamfile.rmdup.bc");
    my $rmdup_reads_total    = $bc->get('sequences');
    my $rmdup_reads_mapped   = $bc->get('reads_mapped');
    my $rmdup_bases_mapped_c = $bc->get('bases_mapped_cigar');
    my $rmdup_bases_total    = $bc->get('total_length');
    my $rmdup_bases_trimmed  = $bc->get('bases_trimmed');

    open(my $fh,'>',$outfile) or Utils::error("$outfile: $!");

    printf $fh "reads total .. %d\n", $reads_total;
    printf $fh "     mapped .. %d (%.1f%%)\n", $reads_mapped, $reads_mapped*100./$reads_total;
    printf $fh "     paired .. %d (%.1f%%)\n", $reads_paired, $reads_paired*100./$reads_total;
    printf $fh "bases total .. %d\n", $bases_total;
    printf $fh "    clip bases     .. %d (%.1f%%)\n", ($bases_total-$bases_trimmed),($bases_total-$bases_trimmed)*100./$bases_total;
    printf $fh "    mapped (read)  .. %d (%.1f%%)\n", $bases_mapped, $bases_mapped*100./$bases_total;
    printf $fh "    mapped (cigar) .. %d (%.1f%%)\n", $bases_mapped_c, $bases_mapped_c*100./($bases_total-$bases_trimmed);
    printf $fh "error rate  .. %f\n", $error_rate;
    printf $fh "rmdup\n";
    printf $fh "     reads total  .. %d (%.1f%%)\n", $rmdup_reads_total, $rmdup_reads_total*100./$reads_total;
    printf $fh "     reads mapped .. %d (%.1f%%)\n", $rmdup_reads_mapped, $rmdup_reads_mapped*100./$rmdup_reads_total;
    printf $fh "     bases mapped (cigar) .. %d (%.1f%%)\n", $rmdup_bases_mapped_c, $rmdup_bases_mapped_c*100./($rmdup_bases_total-$rmdup_bases_trimmed);
    printf $fh "duplication .. %f\n", 1-$rmdup_reads_mapped/$reads_mapped;
    printf $fh "\n";
    printf $fh "insert size        \n";
    printf $fh "    average .. %.1f\n", $avg_isize;
    printf $fh "    std dev .. %.1f\n", $sd_insert_size;
    printf $fh "\n";
    close $fh;
}


#----------- auto_qc ---------------------

sub auto_qc_requires
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my $name = $$self{lane};
    my @requires = ("$sample_dir/_graphs.done");
    return \@requires;
}

# See description of update_db.
#
sub auto_qc_provides
{
    my ($self) = @_;

    if ( exists($$self{db}) ) { return 0; }

    my @provides = ();
    return \@provides;
}

sub auto_qc
{
    my ($self,$lane_path,$lock_file) = @_;

    # Skip Auto QC
    if(exists $$self{'skip_auto_qc'} && $$self{'skip_auto_qc'})
    { $self->debug("Skipping auto_qc.\n"); return $$self{'Yes'}; }

    my $sample_dir = "$lane_path/$$self{sample_dir}";
    if ( !$$self{db} ) { $self->throw("Expected the db key.\n"); }

    my $vrtrack   = VRTrack::VRTrack->new($$self{db}) or $self->throw("Could not connect to the database: ",join(',',%{$$self{db}}),"\n");
    my $name      = $$self{lane};
    my $vrlane    = VRTrack::Lane->new_by_hierarchy_name($vrtrack,$name) or $self->throw("No such lane in the DB: [$name]\n");

    if ( !$vrlane->is_processed('import') ) { return $$self{Yes}; }

    # Init the bamcheck parser
    my $bc = VertRes::Parser::bamcheck->new(file=>"$sample_dir/$name.bam.bc");

    my @qc_status = ();
    my ($test,$status,$reason);
    my $bam_has_seq = 1;
    #Checking to see if the Bam file contains any reads as this crashes other parts of auto_qc 
    if ( $bc->get('sequences') == 0 && $bc->get('total_length') == 0 )
    {
    	$bam_has_seq = 0;
    	push @qc_status, { test=>'Empty bamfile check', status=>0, reason=>'The Bam file provided for this lane contains no sequences.' };
    }
    
    # Genotype check results
    if ( exists($$self{auto_qc}{gtype_regex}) && !(exists $$self{'skip_genotype'} && $$self{'skip_genotype'}) )
    {
        my $gtype  = VertRes::Utils::GTypeCheck::get_status("$sample_dir/${name}.gtype");
        $test   = 'Genotype check';
        $status = 1;
        $reason = qq[The status is '$$gtype{status}'.];
        if ( !($$gtype{status}=~$$self{auto_qc}{gtype_regex}) ) 
        { 
            $status=0; 
            $reason="The status ($$gtype{status}) does not match the regex ($$self{auto_qc}{gtype_regex})."; 
        }
        push @qc_status, { test=>$test, status=>$status, reason=>$reason };
    }

    # Mapped bases
    if ( exists($$self{auto_qc}{mapped_bases}) && $bam_has_seq )
    {
        my $min = $$self{auto_qc}{mapped_bases};
        $test   = 'Mapped bases';
        $status = 1;
        my $clip_bases = $bc->get('total_length') - $bc->get('bases_trimmed');
        my $bases_mapped_c = $bc->get('bases_mapped_cigar');
        my $value = 100. * $bases_mapped_c / $clip_bases ;
        $reason = sprintf "At least %.1f%% bases mapped after clipping (%.2f%%).",$min,$value;
        if ( $value < $min ) { $status=0; $reason = sprintf "Less than %.1f%% bases mapped after clipping (%.2f%%).",$min,$value; }
        push @qc_status, { test=>$test, status=>$status, reason=>$reason };
    }

    # Error rate
    if ( exists($$self{auto_qc}{error_rate}) )
    {
        my $min = $$self{auto_qc}{error_rate};
        $test   = 'Error rate';
        $status = 1;
        my $error_rate = $bc->get('error_rate');
        $reason = "The error rate smaller than $min ($error_rate).";
        if ( $error_rate > $min ) { $status=0; $reason="The error rate higher than $min ($error_rate)."; }
        push @qc_status, { test=>$test, status=>$status, reason=>$reason };
    }

    #  May not have any indels
    my $indel_distribution_exists = 0;
    eval {
        $bc->get('indel_dist');
        $indel_distribution_exists = 1;
    };
    
        
    # Number of insertions vs deletions 
    if ( exists($$self{auto_qc}{max_ins_to_del_ratio}) && $indel_distribution_exists == 1)
    {
        my $max = $$self{auto_qc}{max_ins_to_del_ratio};
        $test   = 'InDel ratio';
        $status = 1;
        my ($inum,$dnum);
        my $counts = $bc->get('indel_dist');
        for my $row (@$counts)
        {
            $inum += $$row[1];
            $dnum += $$row[2];
        }
        if ( !$dnum or $inum/$dnum > $max )  { $status=0; $reason="The Ins/Del ratio bigger than $max ($inum/$dnum)"; }
        push @qc_status, { test=>$test, status=>$status, reason=>$reason };
    }

    $vrtrack->transaction_start();

    # Insert size. 
    if ( $vrlane->is_paired() && exists($$self{auto_qc}{inserts_peak_win}) && exists($$self{auto_qc}{inserts_within_peak}) && $bam_has_seq )
    {
    	$test = 'Insert size';

		if ( $bc->get('reads_paired') == 0 )
        { 
            push @qc_status, { test=>$test, status=>0, reason=>'Zero paired reads, yet flagged as paired' };
        }
        elsif ( $bc->get('avg_insert_size') == 0.0 || !$bc->get('insert_size') ) 
        { 
            push @qc_status, { test=>$test, status=>0, reason=>'The insert size not available, yet flagged as paired' };
        }
        else
        {
            # Only libraries can be failed based on wrong insert size. The lanes are always passed as
            #   long as the insert size is consistent with other lanes from the same library.

            my $peak_win    = $$self{auto_qc}{inserts_peak_win};
            my $within_peak = $$self{auto_qc}{inserts_within_peak};

            $status = 1;
            
            my $isizes = $bc->get('insert_size');	
            my ($amount,$range) = insert_size_ok($isizes,$peak_win,$within_peak);
            $reason = sprintf "There are %.1f%% or more inserts within %.1f%% of max peak (%.2f%%).",$within_peak,$peak_win,$amount;
            if ( $amount<$within_peak ) 
            { 
                $status=0; $reason = sprintf "Fail library, less than %.1f%% of the inserts are within %.1f%% of max peak (%.2f%%).",$within_peak,$peak_win,$amount; 
            }
            push @qc_status, { test=>$test, status=>1, reason=>$reason };

            my $range_str = defined $range ? sprintf "%.2f%%",$range : "undef";
            $reason = sprintf "%.1f%% of inserts are contained within %.1f%% of the max peak (%s).",$within_peak,$peak_win,$range_str;
            if ( $range>$peak_win || !defined $range )
            {
                $status=0; $reason = sprintf "Fail library, %.1f%% of inserts are not within %.1f%% of the max peak (%s).",$within_peak,$peak_win,$range_str;
            }
            push @qc_status, { test=>'Insert size (rev)', status=>1, reason=>$reason };

            my $vrlib = VRTrack::Library->new_by_field_value($vrtrack,'library_id',$vrlane->library_id()) or $self->throw("No vrtrack library?");
            $vrlib->auto_qc_status($status ? 'passed' : 'failed');
            $vrlib->update();
        }
    }


    # Now output the results.
    open(my $fh,'>',"$sample_dir/auto_qc.txt") or $self->throw("$sample_dir/auto_qc.txt: $!");
    $status = 1;
    for my $stat (@qc_status)
    {
        if ( !$$stat{status} ) { $status=0; }
        print $fh "$$stat{test}:\t", ($$stat{status} ? 'PASSED' : 'FAILED'), "\t # $$stat{reason}\n";
    }
    print $fh "Verdict:\t", ($status ? 'PASSED' : 'FAILED'), "\n";
    close($fh);

    # Then write to the database.
    $vrlane->auto_qc_status($status ? 'passed' : 'failed');
    $vrlane->update();
    $vrtrack->transaction_commit();

    return $$self{'Yes'};
}


# vals, calculates 
#   1) what percentage of the data lies within the allowed range from the max peak (e.g. [mpeak*(1-0.25),mpeak*(1+0.25)])
#   2) how wide is the distribution - how wide has to be the range to accomodate the given amount of data (e.g. 80% of the reads) 
sub insert_size_ok
{
    my ($vals,$maxpeak_range,$data_amount) = @_;

    # Determine the max peak
    my $count     = 0;
    my $imaxpeak  = 0;
    my $ndata     = scalar @$vals;
    my $total_count = 0;
    my $max = 0;
    for (my $i=0; $i<$ndata; $i++)
    {
        my $xval = $$vals[$i][0];
        my $yval = $$vals[$i][1];

        $total_count += $yval;
        if ( $max < $yval ) { $imaxpeak = $i; $max = $yval; }
    }

    # See how many reads are within the max peak range
    $maxpeak_range *= 0.01;
    $count = 0;
    for (my $i=0; $i<$ndata; $i++)
    {
        my $xval = $$vals[$i][0];
        my $yval = $$vals[$i][1];

        if ( $xval<$$vals[$imaxpeak][0]*(1-$maxpeak_range) ) { next; }
        if ( $xval>$$vals[$imaxpeak][0]*(1+$maxpeak_range) ) { next; }
        $count += $yval;
    }
    my $out_amount = 100.0*$count/$total_count;

    # return range as undef if max insert peak at zero.
    return($out_amount,undef) unless $$vals[$imaxpeak][0];


    # How big must be the range in order to accomodate the requested amount of data
    $data_amount *= 0.01;
    my $idiff = 0;
    $count = $$vals[$imaxpeak][1];
    while ( $count/$total_count < $data_amount )
    {
        $idiff++;
        if ( $idiff<=$imaxpeak ) { $count += $$vals[$imaxpeak-$idiff][1]; }
        if ( $idiff+$imaxpeak<$ndata ) { $count += $$vals[$imaxpeak+$idiff][1]; }

        # This should never happen, unless $data_range is bigger than 100%
        if ( $idiff>$imaxpeak && $idiff+$imaxpeak>=$ndata ) { last; }
    }
    my $out_range  = $idiff<=$imaxpeak ? $$vals[$imaxpeak][0]-$$vals[$imaxpeak-$idiff][0] : $$vals[$imaxpeak][0];
    my $out_range2 = $idiff+$imaxpeak<$ndata ? $$vals[$imaxpeak+$idiff][0]-$$vals[$imaxpeak][0] : $$vals[-1][0]-$$vals[$imaxpeak][0];
    if ( $out_range2 > $out_range ) { $out_range=$out_range2; }
    $out_range = 100.0*$out_range/$$vals[$imaxpeak][0];

    return ($out_amount,$out_range);
}


#----------- update_db ---------------------

sub update_db_requires
{
    my ($self) = @_;
    my $sample_dir = $$self{'sample_dir'};
    my $name = $$self{lane};
    my @requires = ("$sample_dir/_graphs.done");
    return \@requires;
}

# This subroutine will check existence of the key 'db'. If present, it is assumed
#   that QC should write the stats and status into the VRTrack database. In this
#   case, 0 is returned, meaning that the task must be run. The task will change the
#   QC status from 'no_qc' to something else, therefore we will not be called again.
#
#   If the key 'db' is absent, the empty list is returned and the database will not
#   be written.
#
sub update_db_provides
{
    my ($self) = @_;

    if ( exists($$self{db}) ) { return 0; }

    my @provides = ();
    return \@provides;
}

sub update_db
{
    my ($self,$lane_path,$lock_file) = @_;

    my $sample_dir = "$lane_path/$$self{sample_dir}";
    if ( !$$self{db} ) { $self->throw("Expected the db key.\n"); }

    # First check if the 'no_qc' status is still present. Another running pipeline
    #   could have queued the job a long time ago and the stats might have been
    #   already written.
    my $vrtrack   = VRTrack::VRTrack->new($$self{db}) or $self->throw("Could not connect to the database: ",join(',',%{$$self{db}}),"\n");
    my $name      = $$self{lane};
    my $vrlane    = VRTrack::Lane->new_by_hierarchy_name($vrtrack,$name) or $self->throw("No such lane in the DB: [$name]\n");

    if ( !$vrlane->is_processed('import') ) { return $$self{Yes}; }

    # Get the stats
    my $bc = VertRes::Parser::bamcheck->new(file=>"$sample_dir/$name.bam.bc");
    my $reads_total    = $bc->get('sequences');
    my $reads_mapped   = $bc->get('reads_mapped');
    my $reads_paired   = $bc->get('reads_paired');
    my $bases_total    = $bc->get('total_length');
    my $bases_trimmed  = $bc->get('bases_trimmed');
    my $bases_mapped   = $bc->get('bases_mapped');
    my $bases_mapped_c = $bc->get('bases_mapped_cigar');
    my $error_rate     = $bc->get('error_rate');
    my $avg_isize      = $bc->get('avg_insert_size');
    my $sd_isize       = $bc->get('sd_insert_size');
    
    if( ! looks_like_number($error_rate) || $error_rate < 0  || $error_rate eq '-nan')
    {
    	$error_rate     = 0;
    }

    $bc = VertRes::Parser::bamcheck->new(file=>"$sample_dir/$name.bam.rmdup.bc");
    my $rmdup_reads_total    = $bc->get('sequences');
    my $rmdup_reads_mapped   = $bc->get('reads_mapped');
    my $rmdup_bases_mapped_c = $bc->get('bases_mapped_cigar');
    my $rmdup_bases_total    = $bc->get('total_length');
    my $rmdup_bases_trimmed  = $bc->get('bases_trimmed');

    my $gtype;
    unless(exists $$self{'skip_genotype'} && $$self{'skip_genotype'})
    {
	    # Get genotype results
	    $gtype = VertRes::Utils::GTypeCheck::get_status("$sample_dir/${name}.gtype");
    }
    else
    {
	    # Skip genotype results
	    $gtype = {
            status   => 'unchecked',
            expected => undef,
            found    => undef,
            ratio    => undef,
        };
    }

    my %images = ();
    if ( -e "$sample_dir/chrom-distrib.png" ) { $images{'chrom-distrib.png'} = 'Chromosome Coverage'; }
    if ( -e "$sample_dir/gc-content.png" ) { $images{'gc-content.png'} = 'GC Content'; }
    if ( -e "$sample_dir/insert-size.png" ) { $images{'insert-size.png'} = 'Insert Size'; }
    if ( -e "$sample_dir/gc-depth.png" ) { $images{'gc-depth.png'} = 'GC Depth'; }
    if ( -e "$sample_dir/gc-depth-ori.png" ) { $images{'gc-depth-ori.png'} = 'GC Depth'; }
    if ( -e "$sample_dir/fastqcheck_1.png" ) { $images{'fastqcheck_1.png'} = 'FastQ Check 1'; }
    if ( -e "$sample_dir/fastqcheck_2.png" ) { $images{'fastqcheck_2.png'} = 'FastQ Check 2'; }
    if ( -e "$sample_dir/fastqcheck.png" ) { $images{'fastqcheck.png'} = 'FastQ Check'; }
    if ( -e "$sample_dir/quals.png" ) { $images{'quals.png'} = 'Qualities'; }
    if ( -e "$sample_dir/quals2.png" ) { $images{'quals2.png'} = 'Qualities'; }
    if ( -e "$sample_dir/quals3.png" ) { $images{'quals3.png'} = 'Qualities'; }
    if ( -e "$sample_dir/quals-hm.png" ) { $images{'quals-hm.png'} = 'Qualities'; }
    if ( -e "$sample_dir/coverage.png" ) { $images{'coverage.png'} = 'Coverage'; }
    if ( -e "$sample_dir/acgt-cycles.png" ) { $images{'acgt-cycles.png'} = 'ACGT Cycles'; }
    if ( -e "$sample_dir/mism-per-cycle.png" ) { $images{'mism-per-cycle.png'} = 'Mismatches per cycle'; }
    if ( -e "$sample_dir/indel-cycles.png" ) { $images{'indel-cycles.png'} = 'Indels per cycle'; }
    if ( -e "$sample_dir/indel-dist.png" ) { $images{'indel-dist.png'} = 'Indel distribution'; }

    my $nadapters = 0;
    if ( -e "$sample_dir/${name}_1.nadapters" ) { $nadapters += do "$sample_dir/${name}_1.nadapters"; }
    if ( -e "$sample_dir/${name}_2.nadapters" ) { $nadapters += do "$sample_dir/${name}_2.nadapters"; }

    # Length of reference sequence mapped (for TrackQC_Fasta pipeline.)
    my $sequence_mapped = undef;
    if ( -e "$sample_dir/${name}.cover" ) { $sequence_mapped = do "$sample_dir/${name}.cover"; }
    
    
    my $percentage_reads_with_transposon = undef;
    if ( -e "$sample_dir/${name}.transposon" ) { $percentage_reads_with_transposon = do "$sample_dir/${name}.transposon"; }

    $vrtrack->transaction_start();

    # Now call the database API and fill the mapstats object with values
    my $mapping;
    my $has_mapstats = 0;
    my $mapstats_id;

    if ( -e "$sample_dir/$$self{mapstat_id}" )
    {
        # When run on bam files created by the mapping pipeline, reuse existing
        #   mapstats, so that the mapper and assembly information is not overwritten.
        ($mapstats_id) = `cat $sample_dir/$$self{mapstat_id}`;
        chomp($mapstats_id);
        $mapping = VRTrack::Mapstats->new($vrtrack, $mapstats_id);
        if ( $mapping ) { $has_mapstats=1; }
    }
    if ( !$mapping ) { $mapping = $vrlane->add_mapping(); }

    # Fill the values in
    $mapping->raw_reads($reads_total);
    $mapping->raw_bases($bases_total);
    $mapping->reads_mapped($reads_mapped);
    $mapping->reads_paired($reads_paired);
    $mapping->bases_mapped($bases_mapped_c);
    $mapping->error_rate($error_rate);
    $mapping->rmdup_reads_mapped($rmdup_reads_mapped);
    $mapping->rmdup_bases_mapped($rmdup_bases_mapped_c);
    $mapping->adapter_reads($nadapters);
    $mapping->clip_bases($bases_total-$bases_trimmed);
    $mapping->percentage_reads_with_transposon($percentage_reads_with_transposon);
    $mapping->is_qc(1);

    $mapping->mean_insert($avg_isize);
    $mapping->sd_insert($sd_isize);

    $mapping->genotype_expected($$gtype{expected});
    $mapping->genotype_found($$gtype{found});
    $mapping->genotype_ratio($$gtype{ratio});
    $vrlane->genotype_status($$gtype{status});

    # If there is no mapstats present, the mapper and assembly must be filled in.
    $self->_update_mapper_and_assembly($sample_dir, $mapping) unless $has_mapstats;

    # Do the images
    while (my ($imgname,$caption) = each %images)
    {
        my $img = $mapping->add_image_by_filename("$sample_dir/$imgname");
        $img->caption($caption);
        $img->update;
    }

    # Length of reference sequence mapped
    if(defined $sequence_mapped)
    { 
	$mapping->target_bases_mapped($$sequence_mapped[0]); 
	$mapping->mean_target_coverage($$sequence_mapped[1]); 
	$mapping->target_coverage_sd($$sequence_mapped[2]); 
    }
    $mapping->update;

    # Write the QC status. Never overwrite a QC status set previously by human. Only NULL or no_qc can be overwritten.
    $self->_write_QC_status($vrtrack, $vrlane, $name);

    $vrtrack->transaction_commit();

    # Clean the big files
    for my $file ('gc-depth.bindepth',"$$self{lane}.bam.bai","$$self{lane}*.sai","$$self{lane}*.fastq.gz","$$self{lane}.bam","$$self{lane}.glf")
    {
        Utils::CMD("rm -f $sample_dir/$file");
    }

    if ( $$self{clean_fastqs} )
    {
        Utils::CMD("rm -f $lane_path/$$self{lane}*.fastq.gz");
    }
    
    unlink($lane_path."/.renamed.".$$self{lane}.'_1.fastq.gz') if( -e $lane_path."/.renamed.".$$self{lane}.'_1.fastq.gz');
    unlink($lane_path."/.renamed.".$$self{lane}.'_2.fastq.gz') if( -e $lane_path."/.renamed.".$$self{lane}.'_2.fastq.gz');

    # Rename the sample dir by mapstats ID, cleaning existing one
    if ( $has_mapstats && $mapstats_id )
    {
        # Check if the sample dir is a symlink to reused $sample_dir.$mapstats_id directory.
        #   In that case keep the .id directory and remove $sample_dir. Otherwise rename
        #   $sample_dir to the .id dir.
        my $link;
        if ( -l $sample_dir && ($link=readlink($sample_dir)) && $link=~m{\.$mapstats_id/*$} )
        {
            unlink($sample_dir);
        }
        else
        {
            Utils::CMD("rm -rf $sample_dir.$mapstats_id");
            rename($sample_dir,"$sample_dir.$mapstats_id");
        }
    }
    $self->update_file_permissions($lane_path);
    return $$self{'Yes'};
}


#---------- Debugging and error reporting -----------------

sub format_msg
{
    my ($self,@msg) = @_;
    return '['. scalar gmtime() ."]\t". join('',@msg);
}

sub warn
{
    my ($self,@msg) = @_;
    my $msg = $self->format_msg(@msg);
    if ($self->verbose > 0) 
    {
        print STDERR $msg;
    }
    $self->log($msg);
}

sub debug
{
    # The granularity of verbose messaging does not make much sense
    #   now, because verbose cannot be bigger than 1 (made Base.pm
    #   throw on warn's).
    my ($self,@msg) = @_;
    if ($self->verbose > 0) 
    {
        my $msg = $self->format_msg(@msg);
        print STDERR $msg;
        $self->log($msg);
    }
}

sub throw
{
    my ($self,@msg) = @_;
    my $msg = $self->format_msg(@msg);
    Utils::error($msg);
}

sub log
{
    my ($self,@msg) = @_;

    my $msg = $self->format_msg(@msg);
    my $status  = open(my $fh,'>>',$self->log_file);
    if ( !$status ) 
    {
        print STDERR $msg;
    }
    else 
    { 
        print $fh $msg; 
    }
    if ( $fh ) { close($fh); }
}


sub _update_mapper_and_assembly {
    my ($self, $sample_dir, $mapping) = @_;
    my $parser;

    #   First rely on the config file and if the info is not present there, make a guess
    #   from the bam file header.
    if ( !$$self{mapper} or !$$self{assembly} or !$$self{mapper_version} ) 
    {
        $parser = VertRes::Parser::bam->new(file=>"$sample_dir/$$self{lane}.bam");
    }
    if ( !$$self{assembly} ) 
    {
        my @info = $parser->sequence_info();
        if ( @info ) { $$self{assembly} = $info[1]{AS}; }
    }
    if ( !$$self{mapper} or !$$self{mapper_version} )
    {
        $$self{mapper} = $parser->program();
        if ( $$self{mapper} )
        {
            my %prgs = $parser->program_info();
            $$self{mapper_version} = $prgs{$$self{mapper}}{VN};
        }
    }

    if ( !$$self{assembly} ) { $self->throw("Expected the assembly key.\n"); }
    if ( !$$self{mapper} ) { $self->throw("Expected the mapper key.\n"); }
    if ( !$$self{mapper_version} ) { $self->throw("Expected the mapper_version key.\n"); }

    my $assembly = $mapping->assembly($$self{assembly});
    if (!$assembly) { $assembly = $mapping->add_assembly($$self{assembly}); }

    my $mapper = $mapping->mapper($$self{mapper},$$self{mapper_version});
    if (!$mapper) { $mapper = $mapping->add_mapper($$self{mapper},$$self{mapper_version}); }
}


sub _write_QC_status {
    my ($self, $vrtrack, $vrlane, $name) = @_;
    $vrlane->is_processed('qc',1);
    my $qc_status = $vrlane->qc_status();
    if ( !$qc_status || $qc_status eq 'no_qc' ) { $vrlane->qc_status('pending'); } # Never change status which was set manually
    $vrlane->update;

    my $vrlibrary = VRTrack::Library->new($vrtrack,$vrlane->library_id()) or $self->throw("No such library in the DB: lane=[$name]\n");
    $qc_status = $vrlibrary->qc_status();
    if ( !$qc_status || $qc_status eq 'no_qc' ) 
    { 
        $vrlibrary->qc_status('pending'); 
        $vrlibrary->update(); 
    }
}

1;

