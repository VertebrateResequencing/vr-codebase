#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#

use strict;
use warnings;
use Carp;
use Utils;

my $runner = myRunner->new();
$runner->run();

exit;

#--------------------------------

package myRunner;
use base qw(Runner);
use strict;
use warnings;

sub new
{
    my ($class,@args) = @_;
    my $self = $class->SUPER::new(@args);

    $$self{do_clean} = 1;
    $$self{config_version} = '1378190340';
    $$self{good_vcf}     = '/lustre/scratch105/projects/g1k/ref/broad_resources_b37/hapmap_3.3.b37.sites.vcf.gz ' .
                           '/lustre/scratch105/vrpipe/refs/human/ncbi37/resources/Mills_and_1000G_gold_standard.indels.b37.vcf.gz';
    $$self{bcftools}     = 'bcftools';
    $$self{snps} = 
    {
        hard_filters => q[-i '%FILTER=="PASS" && %QUAL>=10'],
        som_args     => q[-l 'QUAL>0.99' -n 0,0.05],
        annots       => 'RPB,MDV,QBD,HWE,VDB,QUAL',
        good_mask    => '10',
        nshuffle_max => 100_000,
        chunk_by     => 50,
    };
    $$self{indels} = 
    {
        hard_filters => q[-i '%FILTER=="PASS" && %QUAL>=10'],
        som_args     => q[-l 'QUAL>0.99' -n 0,0.05],
        annots       => 'RPB,MDV,QBD,HWE,VDB,QUAL',
        good_mask    => '01',
        nshuffle_max => 100_000,
        chunk_by     => 50,
        fa_ref       => '/lustre/scratch105/projects/g1k/ref/main_project/human_g1k_v37.fasta',
    };
    $$self{sanity_check}{hard_filters} = 0.5;
    $$self{sanity_check}{annots_range} = 1;
    $$self{sanity_check}{ngood_sites}  = 1.0;
    $$self{_sampleconf}  = q[
            bcftools     => '] .$$self{bcftools}. q[',

            do_snps      => 1,
            do_indels    => 1,

            # Single VCF or a file with list of file names. Can be overriden by the -i command line argument.
            in_vcf       => undef,

            # Training sites. Multiple files can be given, for both SNPs and indels. Indicate which is which
            # by setting the good_mask below.
            good_vcf     => '] .$$self{good_vcf}. q[',
            sanity_check => 
            {
                # Abort if more than this many percent of good sites are removed by hard filtering
                hard_filters => ] . $$self{sanity_check}{hard_filters} . q[,

                # Abort if some of the requested annotation has min=max
                annots_range => ] . $$self{sanity_check}{annots_range} . q[,

                # Abort if there is less than this many percent of good sites for training is available.
                # To proceed, set the -n option in som_args and turn off this sanity check by setting to 0.
                ngood_sites => ] . $$self{sanity_check}{ngood_sites} . q[,
            },

            # An integral part of this pipeline is an evaluation of the callsets which requires sorting of the
            # sites by the filtering score. This is done by unix sort command (called by "bcftools filter").
            # With very big files it is a good idea to increase sort's buffer size by setting the "limits" and
            # "sort_args" options.
            #   limits    => { memory=>3_300 },
            #   sort_args => '-S 3G',

            # Set the desired annotations and filtering parameters separately for SNPs and INDELs.
            # The mask indicates which of the files contains training sites. For example, to read training
            # sites from the first file, write '10'. To read training sites from both files, set to '11'.
            snps => 
            {
                hard_filters => '] .$$self{snps}{hard_filters}. q[',
                som_args     => q\[] .$$self{snps}{som_args}. q[\],
                annots       => '] .$$self{snps}{annots}. q[',
                good_mask    => '] .$$self{snps}{good_mask}. q[',
                target_tstv  => [ 2.00, 2.40 ],     # Scan in this ts/tv region, use bigger value for exomes, 
                                                    # typically >3.4 or >2.6 when also off-target regions are
                                                    # included.
                nshuffle_max => ] .$$self{snps}{nshuffle_max}. q[,    # maximum number of combinations to try
                chunk_by     => ] .$$self{snps}{chunk_by}. q[,        # number of combinations to pack into one job
            },
            indels => 
            {
                hard_filters => '] .$$self{indels}{hard_filters}. q[',
                som_args     => q\[] .$$self{indels}{som_args}. q[\],
                annots       => '] .$$self{indels}{annots}. q[',
                good_mask    => '] .$$self{indels}{good_mask}. q[',
                target_rc    => [ 0.70, 0.90 ],     # Repeat-consistency, a metric similar to ts/tv for INDELs
                fa_ref       => '] .$$self{indels}{fa_ref}. q[',
                exons        => '/nfs/users/nfs_p/pd3/sandbox/other/20120425-inframe-indels/CCDS-human-GRCh37p6.sorted.txt.gz', # optional, for frame shift vcf check
                nshuffle_max => ] .$$self{indels}{nshuffle_max}. q[,
                chunk_by     => ] .$$self{indels}{chunk_by}. q[,
            },


            # This pipeline can be run on pre-filtered VCFs and the filters can be afterwards applied to the
            # the original unfiltered VCF, see the --apply option. In this case, one may wish to leave the FILTER 
            # field of these sites untouched or, alternatively, one may want to unset existing filters and fill in
            # the missing value "." instead. By default, the filters are left untouched.
            unset_unknowns => 0,


            # The -s functionality is not maintained in this version
            #
            #   scan_nbins   => [ 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 30 ], # list
            #   scan_learn   => [ 0.01, 0.05, 0.10, 0.15, 0.20 ],               # list
            #   scan_th      => [ 0.1, 0.2, 0.3, 0.4, 0.5 ],                    # list


            do_clean => 1, 

            # For sanity checking that your config file is not obsolete. Update the version key in your 
            #  config file to get rid of the warnings.
            version      => '] .$$self{config_version}. q[',
    ]."\n";

    $$self{usage} .= 
        "Usage: run-beautify\n" .
        "Options:\n" .
        "   -a, --apply <type>:<th>:<list>      Apply SOM filter using the given threshold and annotations.\n" .
        "                                           Type is either 'snps' or 'indels', both can be given.\n" .
        "   -c, --clean                         Clean all temporary files\n" .
        "   -i, --input <vcf>                   Input VCF\n" .
        "   -m, --mrProper                      Clean all temporary files leaving only the resulting VCF\n" .
        "   -r, --randomize                     Randomly shuffle annotations to find the best combination\n" .
        "   -s, --scan                          Scan the parameter space to find the best values\n" .
        "   -o, --outdir <dir>                  Output directory\n" .
        "\n";

    return $self;
}

sub parse_args
{
    my ($self) = @_;
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-a' or $arg eq '--apply' ) 
        { 
            my $do_apply = shift(@ARGV); 
            if ( !($do_apply=~/^([^:]+):([^:]+):(\S+)$/) ) { $self->throw("Could not parse the --apply parameter: [$do_apply]\n"); }
            if ( $1 ne 'snps' && $1 ne 'indels' ) { $self->throw("Expected either 'snps' or 'indels' with -a but got '$1': $do_apply\n"); }
            $$self{$1}{apply_th} = $2;
            $$self{$1}{annots}   = $3;
            $$self{$1}{do_apply} = 1;
            $$self{do_apply} = 1;
            next; 
        }
        if ( $arg eq '-c' or $arg eq '--clean' ) { $$self{clean}=1; next; }
        if ( $arg eq '-s' or $arg eq '--scan' ) { $$self{do_scan}=1; next; }
        if ( $arg eq '-r' or $arg eq '--randomize' ) { $$self{do_randomize}=1; next; }
        if ( $arg eq '-o' or $arg eq '--outdir' ) { $$self{outdir}=shift(@ARGV); next; }
        if ( $arg eq '-i' or $arg eq '--input' ) { $$self{in_vcf}=shift(@ARGV); next; }
        if ( $arg eq '-m' or $arg eq '--mrProper' ) { $$self{mrProper}=1; next; }
        $self->throw();
    }
    if ( !$$self{do_snps} && !$$self{do_indels} ) { $self->throw("Neither do_snps nor do_indels key is set!\n"); }
    if ( !$$self{do_apply} && !$$self{do_scan} && !$$self{do_randomize} ) { $self->throw("Missing one of the --apply, --scan or --randomize options\n"); }
    my $nmodes = 0;
    if ( $$self{do_scan} ) { $nmodes++; }
    if ( $$self{do_randomize} ) { $nmodes++; }
    if ( $$self{do_apply} ) { $nmodes++; }
    if ( $nmodes!=1 ) { $self->throw("Only one of the --scan or --randomize or --apply options should be given\n"); }
    if ( exists($$self{version}) && $$self{version} ne $$self{config_version} )
    {
        $self->throw("Warning: Your config file may be out of date, the latest version key is \"$$self{config_version}\". Please run with +sampleconf to see what changed.\n");
    }
    if ( !exists($$self{good_vcf}) ) { $self->throw("Expected 'good_vcf' parameter."); }
    if ( !defined($$self{in_vcf}) ) { $self->throw("Expected -i option."); }
    if ( $$self{clean} ) 
    { 
        $self->clean($$self{outdir});
        $self->all_done;
    }
    if ( $$self{mrProper} )
    {
        $self->mrProper($$self{outdir});
        $self->all_done;
    }
    if ( exists($$self{sort_args}) && defined($$self{sort_args}) ) { $ENV{SORT_ARGS} = $$self{sort_args}; }
    $$self{outdir} =~ s{/+?$}{};
}

sub main
{
    my ($self) = @_;
    $self->parse_args();

    my $outdir = $$self{outdir};
    $self->save_config();

    # Create sites-only VCFs
    my @files = $self->get_file_list($$self{in_vcf});
    for my $file (@files)
    {
        $self->spawn('strip_genotypes',"$outdir/sites/$$file{tmp}.bcf",$$file{file});
    }
    $self->wait;

    # Apply fixed-threshold filters    
    for my $file (@files)
    {
        if ( $$self{do_snps} ) { $self->spawn('hard_filter',"$outdir/prefiltered.snps/$$file{tmp}.bcf",'snps',"$outdir/sites/$$file{tmp}.bcf"); }
        if ( $$self{do_indels} ) { $self->spawn('hard_filter',"$outdir/prefiltered.indels/$$file{tmp}.bcf",'indels',"$outdir/sites/$$file{tmp}.bcf"); }
    }
    $self->wait;

    # Collect annotations
    for my $file (@files)
    {
        if ( $$self{do_snps} ) { $self->spawn('collect_annots',"$outdir/tab.snps/$$file{tmp}.tab.gz","$outdir/prefiltered.snps/$$file{tmp}.bcf",'snps'); }
        if ( $$self{do_indels} ) { $self->spawn('collect_annots',"$outdir/tab.indels/$$file{tmp}.tab.gz","$outdir/prefiltered.indels/$$file{tmp}.bcf",'indels'); }
    }
    $self->wait;

    # Merge per-chromosome files into one file and sanity check the number of discarded good sites
    if ( $$self{do_snps} ) { $self->spawn('merge_annots',"$outdir/snps.tab.gz",'snps',@files); }
    if ( $$self{do_indels} ) { $self->spawn('merge_annots',"$outdir/indels.tab.gz",'indels',@files); }
    $self->wait;

    if ( $$self{do_snps} ) { $self->sanity_check_hard_filters("$outdir/snps.tab.gz.log"); }
    if ( $$self{do_indels} ) { $self->sanity_check_hard_filters("$outdir/indels.tab.gz.log"); }

    # First run with all annotations to create distribution stats. This takes longer
    # and will be re-used by the individual filtering tasks.
    $self->set_limits(%{$$self{limits}}) unless !exists($$self{limits});
    if ( $$self{do_snps} ) { $self->spawn('init_distributions',"$outdir/snps.tab.gz.n", "$outdir/snps.tab.gz", 'snps'); }
    if ( $$self{do_indels} ) { $self->spawn('init_distributions',"$outdir/indels.tab.gz.n", "$outdir/indels.tab.gz", 'indels'); }
    $self->wait;
    $self->set_limits(memory=>undef,runtime=>undef);

    if ( $$self{do_snps} ) { $self->sanity_check_nfile("$outdir/snps.tab.gz.n",'snps'); }
    if ( $$self{do_indels} ) { $self->sanity_check_nfile("$outdir/indels.tab.gz.n",'indels'); }

    my (@snp_annots, @indel_annots);
    if ( $$self{do_snps} ) { my %anns = $self->parse_annots('snps'); @snp_annots = sort keys %anns; }
    if ( $$self{do_indels} ) { my %anns = $self->parse_annots('indels'); @indel_annots = sort keys %anns; }

    if ( $$self{do_randomize} )
    {
        $self->set_limits(%{$$self{limits}}) unless !exists($$self{limits});
        my @snp_tests = $$self{do_snps} ? $self->spawn_randomize('snps', @snp_annots) : ();
        my @indel_tests = $$self{do_indels} ? $self->spawn_randomize('indels', @indel_annots) : ();
        $self->wait;
        $self->set_limits(memory=>undef,runtime=>undef);

        $self->spawn('find_best',"$outdir/randomize.SNP.tab",@snp_tests) unless !$$self{do_snps};
        $self->spawn('find_best',"$outdir/randomize.INDEL.tab",@indel_tests) unless !$$self{do_indels};
        $self->wait;

        $self->spawn('plot_randomize',"$outdir/randomize.SNP.tab.png",'snps') unless !$$self{do_snps};
        $self->spawn('plot_randomize',"$outdir/randomize.INDEL.tab.png",'indels') unless !$$self{do_indels};
        $self->wait;
    }
    elsif ( $$self{do_scan} )
    {
        $self->throw("Sorry, this branch is currently not maintained.\n");
        my @jobs;
        for my $bin (@{$$self{scan_nbins}})
        {
            for my $learn (@{$$self{scan_learn}})
            {
                for my $th (@{$$self{scan_th}}) 
                { 
                    push @jobs, "-a $$self{annots} -m$bin,$learn,$th"
                }
            }
        }
        my @tests;
        my $i = 0;
        while ($i<@jobs)
        {
            my @args = ();
            for (my $j=0; $j<$$self{chunk_by} && $i<@jobs; $j++, $i++)
            {
                push @args, $jobs[$i];
            }
            push @tests, "$outdir/scan/$i.tab";
            $self->spawn('try_filter',"$outdir/scan/$i.tab", @args);
        }
        $self->wait;

        $self->spawn('find_best',"$outdir/scan.tab",@tests);
        $self->wait;
        $self->spawn('plot_scan',"$outdir/scan.tab.png");
        $self->wait;
    }
    elsif ( $$self{snps}{do_apply} or $$self{indels}{do_apply} )
    {
        my $dirname;
        if ( $$self{snps}{do_apply} ) { $dirname = 'snps-' . $$self{snps}{annots} . '-' . $$self{snps}{apply_th}; }
        if ( $$self{indels}{do_apply} ) 
        { 
            if ( defined $dirname ) { $dirname .= '-'; }
            $dirname .= 'indels-' . join(',',$$self{indels}{annots}); 
            $dirname .= '-' . $$self{indels}{apply_th}; 
        }

        # Run the requested filters to generate list of sites with scores
        if ( $$self{snps}{do_apply} ) 
        {
            my $mask = '';
            if ( exists($$self{snps}{good_mask}) ) { $mask = "-g 0$$self{snps}{good_mask}" }
            $self->spawn('apply_init',"$outdir/$dirname/snps/annots.tab",'snps',"$$self{snps}{som_args} $mask",$$self{snps}{annots}); 
        }
        if ( $$self{indels}{do_apply} ) 
        { 
            my $mask = '';
            if ( exists($$self{indels}{good_mask}) ) { $mask = "-g 0$$self{indels}{good_mask}" }
            $self->spawn('apply_init',"$outdir/$dirname/indels/annots.tab",'indels',"$$self{indels}{som_args} $mask -t INDEL -F $$self{indels}{fa_ref}",$$self{indels}{annots}); 
        }
        $self->wait;

        # Apply filtering, create output VCFs
        my @vcfs  = ();
        for my $file (@files)
        {
            my $args;
            if ( $$self{unset_unknowns} ) { $args .= ' -u'; }
            if ( $$self{snps}{do_apply} ) { $args .= " -s $$self{snps}{apply_th} $outdir/$dirname/snps/annots.sites.gz"; }
            if ( $$self{indels}{do_apply} ) { $args .= " -i $$self{indels}{apply_th} $outdir/$dirname/indels/annots.sites.gz"; }

            $self->spawn('apply_filter',"$outdir/$dirname/$$file{tmp}.vcf.gz",$$file{file},$args);
            push @vcfs, "$outdir/$dirname/$$file{tmp}.vcf.gz";
        }
        $self->wait;

        for my $vcf (@vcfs)
        {
            $self->spawn('vcf_stats',"$vcf.filt.vchk",$vcf,'-f PASS');
            $self->spawn('vcf_stats',"$vcf.vchk",$vcf,'');
        }
        $self->wait;
    }

    # Run performance stats and clean
    $self->spawn('runtime_stats',"$outdir/runtime");
    $self->wait;
    $self->clean($outdir) unless !$$self{do_clean};

    $self->all_done;
}

sub spawn_randomize
{
    my ($self,$key,@annots) = @_;
    my $cmbs   = $self->shuffle($$self{$key}{nshuffle_max}, scalar @annots);
    my @tests  = ();
    for (my $i=0; $i<@$cmbs; $i+=$$self{$key}{chunk_by})
    {
        my @args;
        for (my $j=0; $j<$$self{$key}{chunk_by}; $j++)
        {
            if ( $i+$j >= @$cmbs ) { last; }
            my @anns;
            for (my $k=0; $k<@annots; $k++)
            {
                if ( $$cmbs[$i+$j] & (1<<$k) ) { next; }
                push @anns, $annots[$k];
            }
            if ( !@anns ) { next; }
            my $arg = '-a ' . join(',', @anns);
            if ( exists($$self{$key}{good_mask}) ) { $arg .= " -g 0$$self{$key}{good_mask}" }
            if ( $key eq 'indels' ) { $arg .= " -t INDEL -F $$self{$key}{fa_ref}"; }
            push @args, $arg;
        }
        push @tests, "$$self{outdir}/randomize.$key/$i.tab";
        $self->spawn('try_filter',"$$self{outdir}/randomize.$key/$i.tab", $key, @args);
    }
    return (@tests);
}


sub mrProper
{
    my ($self,$outdir) = @_;
    $self->clean($outdir);
}

sub clean
{
    my ($self,$outdir) = @_;
    $self->SUPER::clean($outdir);
    $self->cmd("rm -rf $outdir/randomize.snps");
    $self->cmd("rm -rf $outdir/randomize.indels");
}

sub runtime_stats
{
    my ($self,$outfile) = @_;
    $self->cmd("mkdir -p $outfile.part");
    $self->cmd("runtime-stats $$self{outdir} -p $outfile.part/graph > $outfile.part/stats.txt");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub save_config
{
    my ($self) = @_;
    my $src = $$self{_config};
    my $dst = "$$self{outdir}/annots.conf";
    if ( -e $dst && (stat($src))[9] <= (stat($dst))[9] ) { return; }
    if ( !-d $$self{outdir} ) { $self->cmd("mkdir -p $$self{outdir}"); }
    open(my $fh,'>',$dst) or $self->throw("$dst: $!");
    my $about = $$self{_about};
    $about =~ s/\n/\n# /g;
    print $fh "# $about";
    close($fh);
    $self->cmd("cat $src >> $dst");
}

sub cmd
{
    my ($self,$cmd,%args) = @_;
    if ( $args{log} ) 
    {
        open(my $fh,'>>',$args{log});
        print $fh $cmd."\n";
        close($fh);
    }
    $cmd =~ s/\n/ /g;
    return Utils::CMD($cmd,{verbose=>1});
}

sub tabix_part
{
    my ($self,$vcf) = @_;
    $self->cmd("tabix -p vcf -f $vcf.part");
    rename("$vcf.part.tbi","$vcf.tbi");
    rename("$vcf.part",$vcf);
}

sub shuffle
{
    my ($self, $nmax, $n) = @_;

    # variable number of nested loops
    my (@out, @cnt);
    my ($il, $nl);
    my $i = 0;
    for ($nl=$n; $nl>=1; $nl--)
    {
        for ($il=0; $il<$nl-1; $il++) { $cnt[$il] = 0; }
        $cnt[$nl-1] = -1;
        while (1)
        {
            for ($il=$nl-1; $il>=0; $il--)
            {
                if ( ++$cnt[$il] < $n-$nl+$il+1 ) { last; }
                if ( $il==0 ) { last; }
                $cnt[$il] = 0;
            }
            for ($il=1; $il<$nl; $il++)
            {
                if ( $cnt[$il] <= $cnt[$il-1] ) { $cnt[$il] = $cnt[$il-1] + 1; }
            }

            if ( $cnt[$nl-1] >= $n ) { last; }

            for ($il=0; $il<$nl; $il++) { $out[$i] |= 1<<$cnt[$il]; }
            if ( ++$i >= $nmax ) { last; }
        }
        if ( $i >= $nmax ) { last; }
    }
    return \@out;
}

sub get_file_list
{
    my ($self,$file) = @_;
    my @files;
    if ( !$self->is_file_list($file) ) { push @files, $file; } 
    else
    {
        open(my $fh,'<',$file) or $self->throw("$file: $!");
        while (my $line=<$fh>)
        {
            chomp($line);
            $line =~ s/^\s*//;
            $line =~ s/\s*$//;
            push @files, $line;
        }
        close($fh);
    }
    my @out;
    my %names;
    for my $file (@files)
    {
        my $bname = $self->strip_dir($file);
        $bname  =~ s/.vcf.gz$//;
        $bname  =~ s/.vcf$//;
        $bname  =~ s/.bcf$//;
        my $tmp = $bname;
        my $i = 0;
        while ( exists($names{$tmp}) ) { $tmp = $bname.(++$i); }
        push @out, { file=>$file, tmp=>$tmp };
        $names{$tmp} = 1;
    }
    return (@out);
}

sub is_file_list
{
    my ($self,$file) = @_;
    my @out = `file $file`;
    if ( $out[0]=~/ASCII/ ) { return 1; }
    return 0;
}

sub strip_dir
{
    my ($self,$file) = @_;
    $file =~ s{^.*/}{};
    return $file;
}

sub strip_genotypes
{
    my ($self,$outfile,$infile) = @_;
    $self->cmd("$$self{bcftools} subset -G -ob $infile > $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub hard_filter
{
    my ($self,$outfile,$type,$infile) = @_;
    $self->cmd("$$self{bcftools} filter $$self{$type}{hard_filters} -mx -ou $infile | $$self{bcftools} subset -bv $type - -ob > $outfile.part");
    $self->cmd("$$self{bcftools} index $outfile.part");
    rename("$outfile.part.csi","$outfile.csi") or $self->throw("rename: $outfile.part.csi $outfile.csi");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub parse_annots
{
    my ($self,$key) = @_;
    my @annots = split(/,/,$$self{$key}{annots});
    my %annots = map { $_ => 1 } @annots;
    my @args = split(/\s+/,$$self{$key}{som_args});
    for (my $i=0; $i<@args; $i++)
    {
        my $filt = $args[$i];
        if ( $filt eq '&&' ) { next; }
        if ( $filt=~/^-/ ) 
        { 
            if ( $filt=~/^-l/ ) { $filt = $args[++$i]; }
            else { $i++; next; }
        }
        $filt =~ s/\'//g;
        $filt =~ s/\"//g;

        my ($a,$b) = split(/[>=<]+/, $filt);
        if ( exists($annots{$a}) or exists($annots{$b}) ) { next; }

        use Scalar::Util qw(looks_like_number);
        my $anum = looks_like_number($a);
        my $bnum = looks_like_number($b);
        if ( $anum && $bnum ) { $self->throw("Unable to decide which is which: $filt [$anum,$bnum $a,$b]\n"); }
        if ( !$anum && !$bnum ) { $self->throw("Unable to decide which is which: $filt [$anum,$bnum $a,$b]\n"); }
        if ( !$anum ) { $annots{$a} = 1; } else { $annots{$b} = 1; }
    }
    return %annots;
}

sub collect_annots
{
    my ($self,$outfile,$in_fname,$type) = @_;

    # Prepare command-line arguments
    my %annots = $self->parse_annots($type);
    my $annots = join(',', sort keys %annots);

    # Collect the annotations
    $self->cmd("$$self{bcftools} query -Ha $annots,FILTER $in_fname $$self{good_vcf} | bgzip -c > $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub merge_annots
{
    my ($self,$outfile,$type,@files) = @_;
    open(my $fh,"| bgzip -c > $outfile.part") or $self->throw("bgzip -c > $outfile.part: $!");

    my $ntot  = 0;
    my $ngood = 0;
    my $nflt  = 0;
    my $ngood_flt = 0;
    my $header_printed = 0;
    my @mask;
    for (my $i=0; $i<length($$self{$type}{good_mask}); $i++)
    {
        if ( substr($$self{$type}{good_mask},$i,1) eq '1' ) { push @mask, $i+1; }
    }
    for my $file (@files)
    {
        open(my $in,"gunzip -c $$self{outdir}/tab.$type/$$file{tmp}.tab.gz |") or $self->throw("gunzip -c $$self{outdir}/tab.$type/$$file{tmp}.tab.gz: $!");
        while (my $line=<$in>)
        {
            my @items = split(/\t/, $line);
            my $flt = pop(@items);
            chomp($flt);
            my $out = join("\t", @items);
            if ( $items[0]=~/^#/ )
            {
                if ( !$header_printed ) { print $fh $out."\n"; $header_printed = 1; }
                next;
            }
            my $is_good = 0;
            for my $i (@mask) { if ( substr($items[2],$i,1) eq '1' ) { $is_good = 1; last; } }
            $ntot++;    # total number of sites
            if ( $is_good ) 
            {
                if ( $flt ne 'PASS' ) { $ngood_flt++; } # good sites filtered
                $ngood++;   # good sites total
            }
            if ( $flt ne 'PASS' ) { $nflt++; }
            else
            {
                print $fh $out."\n";
            }
        }
        close($in) or $self->throw("close gunzip -c $$self{outdir}/tab.$type/$$file{tmp}.tab.gz: $!");
    }
    open(my $out,'>',"$outfile.log") or $self->throw("$outfile.log: $!");
    printf $out "ntot\t%d\t# Number of sites total\n", $ntot;
    printf $out "ngood\t%d\t# Number of good sites\n", $ngood;
    printf $out "nflt\t%d\t# Number of filtered sites\n", $nflt;
    printf $out "ngoodf\t%d\t# Number of good filtered sites\n", $ngood_flt;
    printf $out "flt%%\t%f\t# Percent of filtered sites\n", $ntot ? $nflt*100./$ntot : 0;
    printf $out "goodf%%\t%f\t# Percent of good filtered sites\n", $ngood ? $ngood_flt*100./$ngood : 0;
    close($out) or $self->throw("close $outfile.log");

    close($fh) or $self->throw("close bgzip -c > $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub sanity_check_hard_filters
{
    my ($self,$log) = @_;

    if ( !defined $$self{sanity_check}{hard_filters} ) { return; }

    # Check how many good sites were excluded by hard filters
    open(my $fh,'<',$log) or $self->throw("$log: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/^goodf\%\s+(\S+)/ )
        {
            if ( $1 > $$self{sanity_check}{hard_filters} )
            {
                $self->throw("Too many good sites were removed by hard filters ($1, allowed $$self{sanity_check}{hard_filters}). Please consult $log for details.\n");
            }
        }
    }
    close($fh) or $self->throw("close $log");
}

sub sanity_check_nfile
{
    my ($self,$file,$type) = @_;

    my $need_check = 0;
    if ( $$self{sanity_check}{ngood_sites} ) { $need_check = 1; }
    if ( $$self{sanity_check}{annots_range} ) { $need_check = 1; }
    if ( !$need_check ) { return; }

    my %anns = $self->parse_annots($type);
    open(my $fh,'<',$file) or $self->throw("$file: $!");
    my @bad = ();
    my ($ntot,$ngood);
    while (my $line=<$fh>)
    {
        my @items = split(/\t/,$line);
        my $ann = $items[-1];
        chomp($ann);
        if ( !$anns{$ann} ) { next; }
        if ( $items[7]==$items[8] ) { push @bad, $ann; }
        if ( !defined $ntot or $ntot>$items[0] ) { $ntot = $items[0]; }
        if ( !defined $ngood or $ngood>$items[1] ) { $ngood = $items[1]; }
    }
    close($fh);
    if ( $$self{sanity_check}{annots_range} && scalar @bad ) 
    { 
        $self->throw("These annotations do not look right, please leave it out for $type: ", join(',',@bad), " ($file)\n"); 
    }
    if ( $$self{sanity_check}{ngood_sites} && $ngood*100./$ntot < $$self{sanity_check}{ngood_sites} ) 
    { 
        $self->throw(sprintf "Too few good sites for training (%.2f%%), please check the som_args and ngood_sites config keys and $file for details\n", $ngood*100./$ntot); 
    }
}

sub init_distributions
{
    my ($self,$outfile,$tabfile,$key) = @_;

    my $args = $$self{$key}{som_args};
    if ( exists($$self{$key}{good_mask}) ) { $args .= " -g 0$$self{$key}{good_mask}" }
    if ( $key eq 'indels' ) { $args .= " -t INDEL -F $$self{$key}{fa_ref}"; }

    my $type = $key eq 'snps' ? 'SNP' : 'INDEL';

    # Init with the first annotation to avoid using all columns from
    #   annots.tab.gz. Some of them may cause the vcffilter complain, such as
    #   for indels "The annotation RPB does not look good, please leave it out"
    my $ann = $$self{$key}{annots};
    $ann =~ s/,.*//;
    if ( $ann ne '' ) { $ann = "-a $ann"; }
    
    $self->cmd("$$self{bcftools} som $tabfile -p $outfile.part/ $args $ann", log=>"$outfile.log");

    if ( -e "$outfile.plots" ) { $self->cmd("rm -rf $outfile.plots"); }
    rename("$outfile.part","$outfile.plots") or $self->throw("rename $outfile.part $outfile.plots: $!");
    rename("$outfile.plots/annots.n",$outfile) or $self->throw("rename $outfile.plots/annots.n $outfile: $!");
}

sub try_filter
{
    my ($self,$outfile,$key,@args) = @_;

    my $som_args = $$self{$key}{som_args};
    my ($min,$max,$type);
    if ( $key eq 'snps' )
    {
        $min  = $$self{$key}{target_tstv}[0];
        $max  = $$self{$key}{target_tstv}[1];
        $type = 'SNP';
    }
    else
    {
        $min  = $$self{$key}{target_rc}[0];
        $max  = $$self{$key}{target_rc}[1];
        $type = 'INDEL';
    }

    `mkdir -p $outfile.xxx/`;
    open(my $out,">","$outfile.part") or $self->throw("$outfile.part: $!");

    my @best;
    for my $arg (@args)
    {
        $self->cmd("$$self{bcftools} som $$self{outdir}/$key.tab.gz $arg -p $outfile.xxx/ $som_args");
        
        open(my $fh,'<',"$outfile.xxx/annots.tab") or $self->throw("$outfile.xxx/annots.tab: $!");
        while (my $line=<$fh>)
        {
            if ( $line=~/^#/ ) { next; }
            chomp($line);
            my @items = split(/\t/, $line);
            if ( $items[0] < $min ) { next; }
            if ( $items[0] > $max ) { next; }
            print $out $line, "\t$arg\n";
        }
        close($fh) or $self->throw("close $outfile.xxx/annots.tab");
        `rm -rf $outfile.xxx/`;
    }
    close($out) or $self->throw("close $outfile.part");

    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub apply_init
{
    my ($self,$outfile,$type,$args,@annots) = @_;
    my $annots = join(',',@annots);
    `mkdir -p $outfile.part/`;
    $self->cmd("$$self{bcftools} som $$self{outdir}/$type.tab.gz -a $annots -p $outfile.part/ $args");
    $self->cmd("tabix -s4 -b5 -e5 $outfile.part/annots.sites.gz");
    my $outdir = $outfile;
    $outdir =~ s{/[^/]+$}{};
    $self->cmd("mv $outfile.part/* $outdir");
    $self->cmd("rm -rf $outfile.part");
}

sub apply_filter
{
    my ($self,$outfile,$infile,$args) = @_;
    my @chrs = `tabix -l $infile`;
    if ( @chrs == 1 )
    {
        chomp($chrs[0]);
        $args .= " -r $chrs[0]";
    }
    $self->cmd("$$self{bcftools} som $infile $args -oz > $outfile.part");
    $self->tabix_part($outfile);
}

sub vcf_stats
{
    my ($self,$outfile,$vcf,$args) = @_;
    if ( $$self{do_indels} ) { $args .= " -F $$self{indels}{fa_ref}"; }
    if ( $$self{do_indels} && exists($$self{indels}{exons}) ) { $args .= " -e $$self{indels}{exons}"; }
    $self->cmd("$$self{bcftools} stats $args $vcf > $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}


sub tprint
{
    my ($self,$fh,@txt) = @_;
    for my $txt (@txt)
    {
        $txt =~ s/\n[ \t]+/\n/g;
        $txt =~ s/\\t/\t/g;
        $txt =~ s/\n\\t\s*/\n\t/g;
        print $fh $txt;
    }
}

sub find_best
{
    my ($self,$outfile,@jobs) = @_;

    my $cmd = "sort -k1,1gr -k2,2nr > $outfile.part";
    open(my $sort, "| $cmd") or $self->throw("$cmd: $!");
    for my $job (@jobs)
    {
        open(my $fh,'<',$job) or $self->throw("$job: $!");
        while (my $line=<$fh>)
        {
            print $sort $line;
        }
        close($fh) or $self->throw("$job: $!");
    }
    close($sort) or $self->throw("close $sort");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}


sub bignum
{
    my ($num) = @_;
    if ( !defined $num ) { return ''; }
    if ( !($num=~/^\d+$/) ) { return $num; }
    my $len = length($num);
    my $out;
    for (my $i=0; $i<$len; $i++)
    {
        $out .= substr($num,$i,1);
        if ( $i+1<$len && !(($len-$i-1)%3) ) { $out .= ','; }
    }
    return $out;
}

sub calc_rank
{
    my ($self, $dat, $anns) = @_;
    my %out = ();
    for my $tstv (keys %$dat)
    {
        my %rank = ();
        for (my $i=@{$$dat{$tstv}}-1; $i>=0; $i--)
        {
            for my $ann (@{$$dat{$tstv}[$i]{ann}})
            {
                if ( exists($rank{$ann}) ) { next; }
                $rank{$ann} = @{$$dat{$tstv}} - $i;
            }
            if ( scalar keys %rank == scalar keys %$anns ) { last; }
        }
        for my $ann (keys %$anns)
        {
            if ( !exists($rank{$ann}) ) { $rank{$ann} = 1 + scalar keys %$anns; }
            push @{$out{$ann}}, $rank{$ann};
        }
    }
    my %means = ();
    for my $ann (keys %out)
    {
        my @dat = sort { $a<=>$b } @{$out{$ann}};
        $means{$ann} = $dat[ int(0.5*@dat) ];
    }
    my @order = sort { $means{$a}<=>$means{$b} } keys %means;
    return (\%out,\@order);
}

sub round_value
{
    my ($tick, $value) = @_;
    my $rounded = $tick * int($value/$tick);
    if ( $value - $rounded > $tick*0.5 ) { $rounded += $tick; }
    return $rounded;
}

sub plot_randomize
{
    my ($self,$outfile,$key) = @_;

    my $prefix = $outfile;
    $prefix =~ s/\.png$//;

    # Collect data for two plots: 
    #   1) biggest number of sites and best sensitivity by metric, which is ts/tv for SNPs and repeat consistency for indels
    #   2) rank annotation box plot

    my ($min,$max,$metric_name,$step);
    if ( $key eq 'snps' )
    {
        $metric_name = 'ts/tv';
        $min  = $$self{$key}{target_tstv}[0];
        $max  = $$self{$key}{target_tstv}[1];
        $step = 0.01;
        $key  = 'SNP';
    }
    else
    {
        $metric_name = 'repeat consistency';
        $min  = $$self{$key}{target_rc}[0];
        $max  = $$self{$key}{target_rc}[1];
        $step = 0.005;
        $key  = 'INDEL';
    }


    my (%cnts,%sens,%anns);   # keep n-top hits for each segregating value to calculate rank
    open(my $fh,"<",$prefix) or $self->throw("$prefix: $!");
    while (my $line=<$fh>)
    {
        my @items = split(/\t/, $line);
        # Novel:  if ( $items[3] < $min or $items[3] > $max ) { next; }
        my $metric = round_value($step, $items[0]);
        my $cnt    = $items[1];
        my $sns    = $items[2];
        my $novel_metric = $items[3];
        if ( !($items[5]=~/-a\s*(\S+)/) ) { $self->throw("Could not detect annotations in $prefix: $line"); }
        my @annot = split(/,/,$1);
        for my $ann (@annot) { $anns{$ann} = 1; }
        my $rec = { cnt=>$cnt, sns=>$sns, novel=>$novel_metric, ann=>\@annot };
        if ( !exists($cnts{$metric}) ) { push @{$cnts{$metric}}, $rec; }
        else
        {
            my $i;
            for ($i=0; $i<@{$cnts{$metric}}; $i++)
            {
                if ( $cnt < $cnts{$metric}[$i]{cnt} ) { last; }   # sorted in ascending order
            }
            if ( $i>0 ) { splice(@{$cnts{$metric}}, $i, 0, $rec); }
            elsif ( @{$cnts{$metric}}<20 ) { unshift @{$cnts{$metric}}, $rec; } 
            if ( @{$cnts{$metric}}>20 ) { shift @{$cnts{$metric}}; }
        }
        if ( !exists($sens{$metric}) ) { push @{$sens{$metric}}, $rec; }
        else
        {
            my $i;
            for ($i=0; $i<@{$sens{$metric}}; $i++)
            {
                if ( $sns < $sens{$metric}[$i]{sns} ) { last; }
            }
            if ( $i>0 ) { splice(@{$sens{$metric}}, $i, 0, $rec); }
            elsif ( @{$sens{$metric}}<20 ) { unshift @{$sens{$metric}}, $rec; }
            if ( @{$sens{$metric}} > 20 ) { shift @{$sens{$metric}}; }
        }
    }
    close($fh);

    my @anns = sort keys %anns;
    my ($sens_rank,$sens_order) = $self->calc_rank(\%sens, \%anns);
    my ($cnts_rank,$cnts_order) = $self->calc_rank(\%cnts, \%anns);

    open($fh,'>',"$prefix.py") or $self->throw("$prefix.py: $!");
    $self->tprint($fh, "
        import matplotlib as mpl
        mpl.use('Agg')
        import matplotlib.pyplot as plt
        from matplotlib.ticker import ScalarFormatter

    ");
    print $fh "rank_cnts_labels = ['", join("','", @$cnts_order), "']\n";
    print $fh "rank_sens_labels = ['", join("','", @$sens_order), "']\n";
    print $fh "rank_sens_dat = [";
    for my $annot (@$sens_order)
    {
        print $fh "[", join(',', @{$$sens_rank{$annot}}), "],\n";
    }
    print $fh "]\n";
    print $fh "rank_cnts_dat = [";
    for my $annot (@$cnts_order)
    {
        print $fh "[", join(',', @{$$cnts_rank{$annot}}), "],\n";
    }
    $self->tprint($fh, "]
        dat_cnt = [
    ");
    my %annot_sets = ();
    for my $metric (sort {$a<=>$b} keys %cnts)
    {
        my $ann = join(',',@{$cnts{$metric}[-1]{ann}});
        if ( !exists($annot_sets{$ann}) ) { $annot_sets{$ann} = 1 + scalar keys %annot_sets; }
        $ann = $annot_sets{$ann};
        print $fh "[$metric,$cnts{$metric}[-1]{cnt},$cnts{$metric}[-1]{sns},'$ann',$cnts{$metric}[-1]{novel}],\n";
    }
    $self->tprint($fh, "
        ]
        dat_sns = [
    ");
    for my $metric (sort {$a<=>$b} keys %sens)
    {
        my $ann = join(',',@{$cnts{$metric}[-1]{ann}});
        if ( !exists($annot_sets{$ann}) ) { $annot_sets{$ann} = 1 + scalar keys %annot_sets; }
        $ann = $annot_sets{$ann};
        print $fh "[$metric,$sens{$metric}[-1]{sns},'" .bignum($sens{$metric}[-1]{cnt}). "','$ann',", $sens{$metric}[-1]{cnt} ,"],\n";
    }
    $self->tprint($fh, "
        ]
        annots = [
    ");
    for my $key (sort {$annot_sets{$a}<=>$annot_sets{$b}} keys %annot_sets)
    {
        print $fh "[$annot_sets{$key},'$key'],\n";
    }
    $self->tprint($fh, "
        ]
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7,7))
        fmt = ScalarFormatter(useMathText=True)
        fmt.set_scientific(True)
        fmt.set_powerlimits((-3,3))
        ax1.yaxis.set_major_formatter(fmt)
        ax1.yaxis.get_major_formatter().set_scientific(True)
        ax1.boxplot(rank_cnts_dat)
        ax2.boxplot(rank_sens_dat)
        ax1.set_xticklabels(rank_cnts_labels, rotation=45, fontsize='small',va='top',ha='right')
        ax2.set_xticklabels(rank_sens_labels, rotation=45, fontsize='small',va='top',ha='right')
        ax1.set_title('Annotation rank', fontsize='medium')
        ax1.set_ylabel('Count Rank')
        ax2.set_ylabel('Sensitivity Rank')
        if rank_cnts_dat[0][0]*0.8 > rank_cnts_dat[0][-1]: ax1.set_ylim(rank_cnts_dat[0][0]*0.8)
        if rank_sens_dat[0][0]*0.9 > rank_sens_dat[0][-1]: ax2.set_ylim(rank_sens_dat[0][0]*0.9)
        plt.savefig('$prefix.rank.png')
        plt.close()

        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True, figsize=(9,9))
        fmt = ScalarFormatter(useMathText=True)
        fmt.set_scientific(True)
        fmt.set_powerlimits((-3,3))
        ax1.yaxis.set_major_formatter(fmt)
        ax1.yaxis.get_major_formatter().set_scientific(True)
        fmt = ScalarFormatter(useMathText=True)
        fmt.set_scientific(True)
        fmt.set_powerlimits((-3,3))
        ax2.yaxis.set_major_formatter(fmt)
        cols = [x[2] for x in dat_cnt]
        sc1  = ax1.scatter([x[0] for x in dat_cnt],[x[1] for x in dat_cnt],c=cols,edgecolor='none')
        i = 0
        for x,y,d,t in zip([d[0] for d in dat_cnt],[d[1] for d in dat_cnt],[d[2] for d in dat_cnt],[d[3] for d in dat_cnt]):
        \\ti += 1
        \\tif i % 2:
        \\t\\tax1.annotate('%.2f (%s)' % (d,t), xy=(x,y), xytext=(3,3), textcoords='offset points',fontsize='xx-small',rotation=45,va='bottom',ha='left')
        \\telse:
        \\t\\tax1.annotate('%.2f (%s)' % (d,t), xy=(x,y), xytext=(3,-3), textcoords='offset points',fontsize='xx-small',rotation=45,va='top',ha='right')
        ax1.set_ylabel('Number of sites')
        ax1.grid(color='gray')
        from mpl_toolkits.axes_grid1 import make_axes_locatable
        div1 = make_axes_locatable(ax1)
        cax1 = div1.append_axes('right', size='3%', pad=0.1)
        cb1  = fig.colorbar(sc1, cax=cax1)
        cb1.set_label('Sensitivity')
        for t in cb1.ax.get_yticklabels(): t.set_fontsize(9)

        cols = [x[4] for x in dat_sns]
        sc2 = ax2.scatter([x[0] for x in dat_sns],[x[1] for x in dat_sns],c=cols,edgecolor='none')
        i = 0
        for x,y,d,t in zip([d[0] for d in dat_sns],[d[1] for d in dat_sns],[d[2] for d in dat_sns],[d[3] for d in dat_sns]):
        \\ti += 1
        \\tif i % 2:
        \\t\\tax2.annotate('%s (%s)' % (d,t), xy=(x,y), xytext=(0,3), textcoords='offset points',fontsize='xx-small',rotation=45,va='bottom',ha='left')
        \\telse:
        \\t\\tax2.annotate('%s (%s)' % (d,t), xy=(x,y), xytext=(3,-3), textcoords='offset points',fontsize='xx-small',rotation=45,va='top',ha='right')
        for a,b in zip([d[0] for d in annots],[d[1] for d in annots]):
        \\tax2.annotate('(%d) .. %s' % (a,b), xy=(0.01,(len(annots)-a)*0.05+0.03), xytext=(5,0), textcoords='offset points',xycoords='axes fraction',fontsize='xx-small',va='bottom',ha='left')
        ax2.set_ylabel('Sensitivity')
        ax2.grid(color='gray')
        div2 = make_axes_locatable(ax2)
        cax2 = div2.append_axes('right', size='3%', pad=0.1)
        cb2  = fig.colorbar(sc2, cax=cax2, format='%.2e')
        cb2.set_label('Number of sites')
        for t in cb2.ax.get_yticklabels(): t.set_fontsize(9)

        # cols = [x[2] for x in dat_cnt] # uncomment if sensitivity should be the color
        sc3 = ax3.scatter([x[0] for x in dat_cnt],[x[4] for x in dat_cnt],c=cols,edgecolor='none')
        div3 = make_axes_locatable(ax3)
        cax3 = div3.append_axes('right', size='3%', pad=0.1)
        # cb3  = fig.colorbar(sc3, cax=cax3)
        # cb3.set_label('Sensitivity')
        cb3  = fig.colorbar(sc3, cax=cax3, format='%.2e')
        cb3.set_label('Number of sites')
        for t in cb3.ax.get_yticklabels(): t.set_fontsize(9)
        ax3.grid(color='gray')
        ax3.set_ylabel('Novel $metric_name')
        ax3.set_xlabel('$metric_name')

        #plt.subplots_adjust(right=0.82,bottom=0.06,top=0.95,left=0.2,hspace=0.1,wspace=0.05)
        plt.savefig('$prefix.png')
        plt.close()
    ");
    close($fh);

    $self->cmd("python $prefix.py");
}


sub plot_scan
{
    my ($self,$outfile) = @_;

    my $prefix = $outfile;
    $prefix =~ s/\.png$//;

    my %tstv;
    my $t = $$self{target_tstv}[0];
    while ($t<=$$self{target_tstv}[1])
    {
        my $_tstv = sprintf("%.2f", $t);
        $tstv{$_tstv} = 1;
        $t += ($$self{target_tstv}[1] - $$self{target_tstv}[0]) / 5;
    }
    my $tstv_min = ($$self{target_tstv}[1] + $$self{target_tstv}[0])*0.5 - 0.01;
    my $tstv_max = ($$self{target_tstv}[1] + $$self{target_tstv}[0])*0.5 + 0.01;

    my (%win,%learn,%th, %win_learn,%win_th,%learn_th);
    open(my $fh,"<",$prefix) or $self->throw("$prefix: $!");
    while (my $line=<$fh>)
    {
        my @items = split(/\t/, $line);
        my $tstv  = sprintf("%.2f", $items[0]);
        my $cnt   = $items[1];
        my $sns   = $items[2];
        if ( !($items[5]=~/-m\s*(\S+)/) ) { $self->throw("Could not detect annotations in $prefix: $line"); }
        my ($win,$learn,$th) = split(/,/, $1);
        if ( $tstv_min<=$tstv && $tstv<=$tstv_max )
        {
            if ( !exists($win_learn{$win}{$learn}) or $win_learn{$win}{$learn} < $cnt ) { $win_learn{$win}{$learn} = $cnt; }
            if ( !exists($win_th{$win}{$th}) or $win_th{$win}{$th} < $cnt ) { $win_th{$win}{$th} = $cnt; }
            if ( !exists($learn_th{$learn}{$th}) or $learn_th{$learn}{$th} < $cnt ) { $learn_th{$learn}{$th} = $cnt; }
        }
        if ( !exists($tstv{$tstv}) ) { next; }
        if ( !exists($win{$tstv}{$win}) or $win{$tstv}{$win} < $cnt ) { $win{$tstv}{$win} = $cnt; }
        if ( !exists($learn{$tstv}{$learn}) or $learn{$tstv}{$learn} < $cnt ) { $learn{$tstv}{$learn} = $cnt; }
        if ( !exists($th{$tstv}{$th}) or $th{$tstv}{$th} < $cnt ) { $th{$tstv}{$th} = $cnt; }
    }
    close($fh);

    if ( !scalar keys %win_learn ) { $self->throw("No result in the range of tstv=($tstv_min,$tstv_max)?! $prefix\n"); }

    open($fh,'>',"$prefix.py") or $self->throw("$prefix.py: $!");
    $self->tprint($fh, "
        import matplotlib as mpl
        mpl.use('Agg')
        import matplotlib.pyplot as plt
        from matplotlib.ticker import ScalarFormatter

    ");
    print $fh "labels = ['", join("','", sort {$a<=>$b} keys %win), "']\n";
    print $fh "dat_win = [";
    for my $tstv (sort {$a<=>$b} keys %win)
    {
        my (@x,@y);
        for my $win (sort {$a<=>$b} keys %{$win{$tstv}}) { push @x,$win; push @y,$win{$tstv}{$win}; }
        print $fh "[", join(',',@x), "],\n";
        print $fh "[", join(',',@y), "],\n";
    }
    print $fh "]\ndat_learn = [";
    for my $tstv (sort {$a<=>$b} keys %learn)
    {
        my (@x,@y);
        for my $learn (sort {$a<=>$b} keys %{$learn{$tstv}}) { push @x,$learn; push @y,$learn{$tstv}{$learn}; }
        print $fh "[", join(',',@x), "],\n";
        print $fh "[", join(',',@y), "],\n";
    }
    print $fh "]\ndat_th = [";
    for my $tstv (sort {$a<=>$b} keys %th)
    {
        my (@x,@y);
        for my $th (sort {$a<=>$b} keys %{$th{$tstv}}) { push @x,$th; push @y,$th{$tstv}{$th}; }
        print $fh "[", join(',',@x), "],\n";
        print $fh "[", join(',',@y), "],\n";
    }
    print $fh "]\ndat_win_learn = [";
    my (@x,@y,@s);
    for my $win (sort {$a<=>$b} keys %win_learn)
    {
        for my $learn (keys %{$win_learn{$win}}) { push @x,$win; push @y,$learn; push @s,$win_learn{$win}{$learn}; }
    }
    print $fh "[", join(',',@x), "],\n";
    print $fh "[", join(',',@y), "],\n";
    print $fh "[", join(',',@s), "],\n";
    print $fh "]\ndat_win_th = [";
    @x = (); @y = (); @s = ();
    for my $win (sort {$a<=>$b} keys %win_th)
    {
        for my $th (keys %{$win_th{$win}}) { push @x,$win; push @y,$th; push @s,$win_th{$win}{$th}; }
    }
    print $fh "[", join(',',@x), "],\n";
    print $fh "[", join(',',@y), "],\n";
    print $fh "[", join(',',@s), "],\n";
    print $fh "]\ndat_learn_th = [";
    @x = (); @y = (); @s = ();
    for my $learn (sort {$a<=>$b} keys %learn_th)
    {
        for my $th (keys %{$learn_th{$learn}}) { push @x,$learn; push @y,$th; push @s,$learn_th{$learn}{$th}; }
    }
    print $fh "[", join(',',@x), "],\n";
    print $fh "[", join(',',@y), "],\n";
    print $fh "[", join(',',@s), "],\n";
    $self->tprint($fh, "
        ]
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5,8))
        M1  = max(dat_win_learn[2])
        m1  = min(dat_win_learn[2])
        M2  = max(dat_win_th[2])
        m2  = min(dat_win_th[2])
        M3  = max(dat_learn_th[2])
        m3  = min(dat_learn_th[2])
        sc1 = ax1.scatter(dat_win_learn[0],dat_win_learn[1],s=[(x-m1)*100./(M1-m1+1) for x in dat_win_learn[2]], marker='o', c=dat_win_learn[2])
        sc2 = ax2.scatter(dat_win_th[0],dat_win_th[1],s=[(x-m2)*100./(M2-m2+1) for x in dat_win_th[2]], marker='o', c=dat_win_th[2])
        sc3 = ax3.scatter(dat_learn_th[0],dat_learn_th[1],s=[(x-m3)*100./(M3-m3+1) for x in dat_learn_th[2]], marker='o', c=dat_learn_th[2])
        cb1 = fig.colorbar(sc1, ax=ax1, format='%.2e'); cb1.set_label('Number of sites')
        for t in cb1.ax.get_yticklabels(): t.set_fontsize(9)
        cb2 = fig.colorbar(sc2, ax=ax2, format='%.2e'); cb2.set_label('Number of sites')
        for t in cb2.ax.get_yticklabels(): t.set_fontsize(9)
        cb3 = fig.colorbar(sc3, ax=ax3, format='%.2e'); cb3.set_label('Number of sites')
        for t in cb3.ax.get_yticklabels(): t.set_fontsize(9)
        ax1.set_title('Stability of params at ts/tv $tstv_min-$tstv_max', fontsize='medium')
        ax1.set_xlabel('nBins'); ax1.set_ylabel('learning constant')
        ax2.set_xlabel('nBins'); ax2.set_ylabel('threshold')
        ax3.set_xlabel('learning constant'); ax3.set_ylabel('threshold')
        plt.subplots_adjust(right=0.95,bottom=0.06,top=0.95,left=0.2,hspace=0.32)
        plt.savefig('$prefix.2.png')
        plt.close()

        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5,8))
        fmt = ScalarFormatter(useMathText=True)
        fmt.set_scientific(True)
        fmt.set_powerlimits((-3,3))
        ax1.yaxis.set_major_formatter(fmt)
        ax1.yaxis.get_major_formatter().set_scientific(True)
        ax2.yaxis.set_major_formatter(fmt)
        ax2.yaxis.get_major_formatter().set_scientific(True)
        ax3.yaxis.set_major_formatter(fmt)
        ax3.yaxis.get_major_formatter().set_scientific(True)
        for i in range(len(labels)): ax1.plot(dat_win[2*i],dat_win[2*i+1],'-o',label='tstv '+labels[i])
        for i in range(len(labels)): ax2.plot(dat_learn[2*i],dat_learn[2*i+1],'-o',label='tstv '+labels[i])
        for i in range(len(labels)): ax3.plot(dat_th[2*i],dat_th[2*i+1],'-o',label='tstv '+labels[i])
        ax1.legend(frameon=False,numpoints=1,markerscale=0.6,loc='best',prop={'size':9})
        ax2.legend(frameon=False,numpoints=1,markerscale=0.6,loc='best',prop={'size':9})
        ax3.legend(frameon=False,numpoints=1,markerscale=0.6,loc='best',prop={'size':9})
        ax1.set_title('Stability of SOM params', fontsize='medium')
        ax1.set_ylabel('Number of sites')
        ax2.set_ylabel('Number of sites')
        ax3.set_ylabel('Number of sites')
        ax1.set_xlabel('nBins')
        ax2.set_xlabel('learning constant')
        ax3.set_xlabel('threshold')
        plt.subplots_adjust(right=0.95,bottom=0.06,top=0.95,left=0.2,hspace=0.32)
        plt.savefig('$prefix.png')
        plt.close()
    ");
    close($fh);

    `python $prefix.py`;
}

