#!/usr/bin/env perl
use strict;
use warnings;
no warnings 'uninitialized';

use Getopt::Long;
use VertRes::Utils::VRTrackFactory;
use VRTrack::Lane;
use VertRes::Utils::FileSystem;
use File::Path qw(remove_tree);
use Cwd 'abs_path';
use File::Find;
use Filesys::DiskUsage qw/du/;

# Todo: find all files first, then filter as you go along rather than running find multiple times and glob, then blindly testing for the existance of files.


my ( $db, $root, $clean, $help, $verbose, $dry_run, $tmp_directory );

GetOptions(
    'd|db=s'      => \$db,
    'r|root=s'    => \$root,
    'y|dry_run'   => \$dry_run,
    'v|verbose'   => \$verbose,
    't|tempdir=s' => \$tmp_directory,
    'h|help'      => \$help,
);

( $db && !$help ) or die <<USAGE;
Usage: $0 [options] <file of lanes to delete>  
  -d STR specify db name
  -r STR root directory for the analyses
  -y     dont delete anything
  -v     verbose output
  -t STR temp dir on lustre, defaults to [/lustre/scratch118/infgen/pathogen/pathpipe/tmp/]
  -h     this message
USAGE

$tmp_directory ||= '/lustre/scratch118/infgen/pathogen/pathpipe/tmp/';

my $vrtrack = VertRes::Utils::VRTrackFactory->instantiate(
    database => $db,
    mode     => 'rw'
);
unless ($vrtrack) {
    die "Can't connect to tracking database\n";
}
my $total_files_deleted = 0;
my $total_disk_deleted  = 0;
print join(
    "\t",
    (
        "Progress:",  'Lane',      "NumBefore",  "NumAfter",       "Change",       "TotalDeleted",
        "DiskBefore", "DiskAfter", "DiskChange", "TotalDiskSaved", "BytesPerBase", "\n"
    )
);

# get lanes from file of lane names or stdin
while (<>) {
    my $lanename = $_;
    chomp $lanename;

    next if ( length($lanename) < 4 );

    #Check lane actually exists or bail out
    my $vrlane = VRTrack::Lane->new_by_name( $vrtrack, $lanename );
    unless ($vrlane) {
        print "Can't get lane $lanename\n";
        next;
    }
    if ($root) {
        my $lane_suffix_dir = $vrtrack->hierarchy_path_of_lane_name( $vrlane->name );

        # If you dont check this exists then you end up deleting the root directory of the pipeline
        next if ( !defined($lane_suffix_dir) || ( length($lane_suffix_dir) < 10 ) );
        my $lanedir = $root . $lane_suffix_dir . '/';
        next unless ( -d $lanedir );

        my $before_counter = 0;
        find( sub { $before_counter++; }, $lanedir );

        # disk space before
        my $disk_space_before = du($lanedir);

        #    import => 1,
        #	 qc => 2,
        #	 mapped => 4,
        #	 stored => 8,
        # snp_called => 256,
        # rna_seq_expression => 512,
        # assembled  => 1024,
        # annotated  => 2048,

        my @files_to_delete = [];
        if ( $vrlane->is_processed('import') ) {
            for my $file (qw(import_files convert_to_fastq bam2fastq compressfastq import_bams)) {
                foreach my $suffix (qw(o e pl jids)) {
                    push( @files_to_delete, $lanedir . '_' . $file . '.' . $suffix );
                }
            }

            for my $file (
                '_import_done',
                '_import_bams.done',
                '_cram_to_fastq_done',
                '_get_files.jids',
                $vrlane->name . '.cram',
                $vrlane->name . '.cram.md5',
                $vrlane->name . '.bam',
                $vrlane->name . '.bam.md5',
                $vrlane->name . '_1.fastq.gz.md5',
                $vrlane->name . '_2.fastq.gz.md5',
                $vrlane->name . '_1.fastq.md5',
                $vrlane->name . '_2.fastq.md5',
                $vrlane->name . '_1.fastq.fastqcheck',
                $vrlane->name . '_2.fastq.fastqcheck',
              )
            {
                push( @files_to_delete, $lanedir . $file );
            }
        }

        if ( $vrlane->is_processed('qc') ) {
            my $qc_lanedir = $lanedir . 'qc-sample/';

            for my $file (qw(assign_taxonomy new_assign_taxonomy)) {
                foreach my $suffix (qw(o e pl jids)) {
                    push( @files_to_delete, $lanedir . '_' . $file . '.' . $suffix );
                }
            }

            # top level directory
            for my $file (
                '_assign_taxonomy_done',                     '.renamed.' . $vrlane->name . '_1.fastq.gz',
                '.renamed.' . $vrlane->name . '_2.fastq.gz', '_heterozygous_snps_done',
                '_assign_taxonomy.lock'
              )
            {
                push( @files_to_delete, $lanedir . $file );
            }

            for my $glob_pattern ( "*.gp", "*.png", "*.pl", "*.e", "*.o" ) {
                my @globbed_files = glob( $qc_lanedir . $glob_pattern );
                for my $file (@globbed_files) {
                    push( @files_to_delete, $file );
                }
            }



            # within the sample directory
            for my $file (
                $vrlane->name . '_1.fastq.gz',
                $vrlane->name . '_2.fastq.gz',
                $vrlane->name . '.bam',
                $vrlane->name . '.glf',
                $vrlane->name . '.bam.bai',
                $vrlane->name . '_1.sai',
                $vrlane->name . '_2.sai',
                $vrlane->name . '.cover',
                $vrlane->name . '_1.nadapters',
                $vrlane->name . '_2.nadapters',
                $vrlane->name . '.bam.rmdup.bc',
                '_graphs.done',
                'gc-depth.bindepth',
                '_detailed-stats.txt',
                'adapters.fa',
				$vrlane->name . '.gtype',
				$vrlane->name . '.gtypex',
				'Rplots.pdf',
				'_stats.dump',
				'chrom-distrib.png.R',
				'fastqcheck.png.R',
				'fastqcheck_1.png.R',
				'fastqcheck_2.png.R',
				'gc-content.png.R',
				'gc-depth.png-gcdepth.txt',
				'gc-depth.png.R',
				'insert-size.png.R',
              )
            {
                push( @files_to_delete, $qc_lanedir . $file );
            }
        }

        ## Assembly
		
		# If the assembled DB flag isnt set, but the cleanup file is there, then fix the DB
		for my $prefix ( '_assembly_', '_spades_', '_velvet_', '_iva_' ) {
			if( (! $vrlane->is_processed('assembled')) && (-e  $lanedir . $prefix . "assembly_cleanup_done"))
			{
		        $vrtrack->transaction_start();
		        $vrlane->is_processed('assembled', 1);
		        $vrlane->update();
		        $vrtrack->transaction_commit();
				print "Fixing assembly processed flag:\t" .  $lanedir . "\n";
			}
		}
		
        if ( $vrlane->is_processed('assembled') ) {

            for my $prefix ( '_assembly_', '_spades_', '_velvet_', '_iva_', '_assembly_iva_', ) {
                next unless ( -e $lanedir . $prefix . "assembly_cleanup_done" );

                for my $file (qw(pool_fastqs)) {
                    foreach my $suffix (qw(o e pl jids)) {
                        push( @files_to_delete, $lanedir . $prefix . $file . '.' . $suffix );
                    }
                }

                for my $file ('assembly_update_db_done') {
                    push( @files_to_delete, $lanedir . $prefix . $file );
                }

                for my $assembler ( 'velvet', 'spades', 'iva' ) {
					my $assembler_directory = $lanedir . $assembler . '_assembly/';
					next unless(-d $assembler_directory);

                    for my $file (qw(optimise_parameters assembly_improvement map_back iva_qc)) {
                        foreach my $suffix (qw(o e pl jids)) {
                            push( @files_to_delete, $lanedir . $prefix . $assembler . '_' . $file . '.' . $suffix );
                        }
                    }

                    for my $file (
                        '_map_back_done',             '_optimise_parameters_done',
                        '_assembly_improvement_done', '_qc_done',
                        '_pool_fastqs_done',          '_pool_fastq_tmp_files', 
                      )
                    {
                        push( @files_to_delete, $lanedir . $prefix . $assembler . $file );
                    }

                    # Log
                    for my $file (
                        qw/
                        before_rr.fasta
                        contigs.paths
                        input_dataset.yaml
                        split_input
                        tmp
                        contigs.fa.scaffolded.filtered
                        .RData
                        contigs.fa.png.Rout
                        scaffolded.summaryfile.txt
                        forward.fastq
                        reverse.fastq
                        assembly_graph.fastg
                        corrected
                        mismatch_corrector
                        scaffolds.paths
                        _velvet_optimise_parameters_done
                        _spades_optimise_parameters_done
						_velvet_velvet_map_back_done
                        assembly_graph.gfa
                        qc_graphs
                        /
                      )
                    {
                        push( @files_to_delete, $assembler_directory . $file );
                    }
					
					# IVA QC 
					my $iva_qc_dir = $assembler_directory. 'iva_qc/';
					next unless ( -e $iva_qc_dir );
                    for my $file (
                        qw/
                        .RData
						iva_qc.ratt
						iva_qc.assembly.fasta.fai
						iva_qc.reference.fa.fai
						iva_qc.assembly_v_ref.act.sh
						iva_qc.contig_placement.Rout
                        /
                      )
                    {
                        push( @files_to_delete, $assembler_directory . $file );
                    }
					

                    # Remove the tmp directory from lustre
                    push( @files_to_delete, $tmp_directory . $prefix . $assembler . '_' . $vrlane->name );
                }

            }
        }

        # Annotation
        if ( $vrlane->is_processed('annotated') ) {
            for my $prefix ( '_annotate_', '_spades_ann_' ) {
                next unless ( -e $lanedir . $prefix . "annotate_cleanup_done" );

                for my $file (qw(annotate_assembly)) {
                    foreach my $suffix (qw(o e pl jids)) {
                        push( @files_to_delete, $lanedir . $prefix . $file . '.' . $suffix );
                    }
                }

                for my $file ( 'annotate_update_db_done', 'annotate_assembly_done' ) {
                    push( @files_to_delete, $lanedir . $prefix . $file );
                }
				
            }

            for my $assembler ( 'velvet', 'spades', 'iva', 'pacbio' ) {
                my $assembly_directory = $lanedir . $assembler . "_assembly/";
                next unless ( -e $assembly_directory );

                # annotation can leave tens of thousands of temp files sometimes.
                for my $pattern ( '*.hmmsearchresult', '*pos.fsa', '*neg.fsa' ) {
                    my $find_command = "find $assembly_directory -name '$pattern'";
                    my $find_output  = `$find_command`;
                    my @files        = split( /\n/, $find_output );
                    for my $file (@files) {
                        push( @files_to_delete, $file );
                    }
                }
				
				# delete files within the annotation directory itself
                my $annotation_directory = $assembly_directory . "annotation/";
                next unless ( -e $annotation_directory );
	            for my $file (
	                $vrlane->name . '.tbl', $vrlane->name . '.err', $vrlane->name .'.gbk', $vrlane->name .'.fsa'
					)
					{push( @files_to_delete, $file );}
				
            }

        }

        # mapping
        if ( $vrlane->is_processed('mapped') ) {
            for my $mapping_obj ( @{ $vrlane->mappings() } ) {
                next if ( $mapping_obj->is_qc() == 1 );
                next unless ( defined( $mapping_obj->bases_mapped() ) );

                my $mapping_prefix = $mapping_obj->prefix();
                my $mapstats_id    = $mapping_obj->id();

                for my $file (
                    "split_pe_${mapstats_id}", "statistics_${mapstats_id}.pe.raw.sorted.bam",
                    "merge_pe_${mapstats_id}", "mark_duplicates_pe_${mapstats_id}",
                  )
                {
                    foreach my $suffix (qw(o e pl jids)) {
                        push( @files_to_delete, $lanedir . $mapping_prefix . $file . '.' . $suffix );
                    }
                }

                for my $file (
                    "${mapstats_id}.pe.raw.sorted.bam_graphs",   "${mapstats_id}.pe.raw.sorted.bam.cover",
                    "${mapstats_id}.pe.raw.sorted.bam.bc",       "${mapstats_id}.pe.raw.sorted.bam.bas",
                    "${mapstats_id}.pe.raw.sorted.bam.flagstat", "${mapstats_id}.pe.raw.sorted.bam.tmp",
                    "${mapstats_id}.pe.raw.sorted.bam.bad",      "${mapstats_id}.pe.raw.sorted.bam.checked",
                    "${mapping_prefix}job_status",               "${mapping_prefix}split.jids",
                    ".mapping_complete_pe_${mapstats_id}",       ".split_complete_pe_${mapstats_id}",
					".${mapstats_id}.pe.raw.sorted.bam.checked",
                    "split_pe_${mapstats_id}"
                  )
                {
                    push( @files_to_delete, $lanedir . $file );
                }

                # mark dup was run so can safely delete raw.sorted.bam
                if ( -e $lanedir . "${mapstats_id}.pe.markdup.bam" ) {
                    push( @files_to_delete, $lanedir . "${mapstats_id}.pe.raw.sorted.bam" );
                    push( @files_to_delete, $lanedir . "${mapstats_id}.pe.raw.sorted.bam.bai" );
                }

                #"${mapping_prefix}map_pe_${mapstats_id}_[0-9]+.[oe]",
            }
        }

        # snp calling
        if ( $vrlane->is_processed('snp_called') ) {
            for my $mapping_obj ( @{ $vrlane->mappings() } ) {
                next if ( $mapping_obj->is_qc() == 1 );
                next unless ( defined( $mapping_obj->bases_mapped() ) );

                my $mapping_prefix = $mapping_obj->prefix();
                my $mapstats_id    = $mapping_obj->id();

                my $snp_dir = $lanedir . ${mapstats_id} . '.pe.markdup.snp/';
                next unless ( -e $snp_dir . '.snps_done' );

                for my $file ( 'mpileup.unfilt.vcf.gz.stats', 'mpileup.vcf.gz', 'mpileup.vcf.gz.tbi', 'mpileup.vcf.gz.stats',
                    '.pseudo_genome.done' )
                {
                    push( @files_to_delete, $snp_dir . $file );
                }

                my @globbed_files =
                  glob( $snp_dir
                      . "*_pseudo_genome.pl "
                      . $snp_dir
                      . "*_pseudo_genome.e "
                      . $snp_dir
                      . "*_pseudo_genome.o "
                      . $snp_dir
                      . "*_pseudo_genome.jids "
                      . $snp_dir
                      . "*_job_status " );
                for my $file (@globbed_files) {
                    push( @files_to_delete, $file );
                }
            }

            # mpileup directory can have vast numbers of files. Also in fsu exists database table
        }

        # global deletes - these files should always go
        for my $file (qw(store_nfs)) {
            for my $suffix (qw(o e pl jids)) {
                push( @files_to_delete, $lanedir . '_' . $file . '.' . $suffix );
            }
        }
        for my $file ( 'minikraken_20140104.kraken.report', 'pool_1.fastq.gz', '_permissions_job_status' ) {
            push( @files_to_delete, $lanedir . $file );
        }

        # global globs
        my $glob_string = "";
        for my $p ( '.*archive', '.*previous', '*archive', '*previous', 'hs_err_pid*.log' ) {
            $glob_string .= $lanedir . $p . " ";
        }
        my @globbed_files = glob($glob_string);
        for my $file (@globbed_files) {
            push( @files_to_delete, $file );
        }

        #### Failed QC pipeline cleanup
        # If kraken ran, but the QC pipeline failed it can leave very large FASTQ files
        if ( -e $lanedir . '_assign_taxonomy_done' ) {

            for my $file (qw(assign_taxonomy new_assign_taxonomy)) {
                foreach my $suffix (qw(o e pl jids)) {
                    push( @files_to_delete, $lanedir . '_' . $file . '.' . $suffix );
                }
            }

            for my $file ( '.renamed.' . $vrlane->name . '_1.fastq.gz', '.renamed.' . $vrlane->name . '_2.fastq.gz' ) {
                push( @files_to_delete, $lanedir . $file );
            }
        }

        ### Some directories can have vast numbers of files after they fail, cleanup ones older than 1 year.
        for my $pattern (
            'split_pe_*',                 '*.pe.raw.sorted.bam.tmp', '_markdup_tmp_*',        '_job_status',
            '_sga_error_corrected.fastq', '_sga_preprocessed.bwt',   '_sga_preprocessed.sai', '_sga_preprocessed.fastq'
          )
        {
            my $find_command = "find $lanedir -mtime +365 -name '$pattern'";
            my $find_output  = `$find_command`;
            my @files        = split( /\n/, $find_output );
            for my $file (@files) {
                push( @files_to_delete, $file );
            }
        }

        for my $file (@files_to_delete) {

            if ( -d $file ) {
                print "Delete directory:\t" . $file . "\n";
                remove_tree($file) unless ($dry_run);
            }
            elsif ( -l $file ) {
                print "Delete link:\t" . $file . "\n";
                unlink($file) unless ($dry_run);
            }
            elsif ( -e $file ) {
                print "Delete file:\t" . $file . "\n";
                unlink($file) unless ($dry_run);
            }

        }

        # disk space after
        my $disk_space_after = du($lanedir);
        $total_disk_deleted += ( $disk_space_before - $disk_space_after );
        my $bytes_per_base = $disk_space_after / ( $vrlane->raw_bases );

        my $after_counter = 0;
        find( sub { $after_counter++; }, $lanedir );

        $total_files_deleted += ( $before_counter - $after_counter );
        print join(
            "\t",
            (
                "Progress:",                          $vrlane->name,
                $before_counter,                      $after_counter,
                ( $before_counter - $after_counter ), $total_files_deleted,
                int( $disk_space_before / 1000000 ),  int( $disk_space_after / 1000000 ),
                int( ( $disk_space_before - $disk_space_after ) / 1000000 ), int( $total_disk_deleted / 1000000 ),
                $bytes_per_base, "\n"
            )
        );

    }

}

