#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#

use strict;
use warnings;
use Carp;
use Utils;

my $runner = myRunner->new();
$runner->run();

exit;

#--------------------------------

package myRunner;
use base qw(Runner);
use strict;
use warnings;
use VertRes::Stats::Quantile;
use VertRes::Stats::MannWhitney;

sub filter_type
{
    my ($class,@args) = @_;
    my %keys = map { $_ => 1 } @args;
    if ( exists($keys{som}) ) { return 'som'; }
    if ( exists($keys{svm}) ) { return 'svm'; }
    return '';
}

sub new
{
    my ($class,@args) = @_;
    my $self = $class->SUPER::new(@args);

    $$self{config_version} = '1384418534';
    $$self{merge_files}  = 1;
    $$self{do_clean}     = 1;
    $$self{ngood_max}    = 1_000;
    $$self{nbad_max}     = 1_000;
    $$self{scale_qlow}   = 0.1;
    $$self{scale_qhigh}  = 99.9;
    $$self{qaccuracy}    = 99.0;
    $$self{good_site}    = 2;
    $$self{bad_site}     = 1;
    $$self{verbose}      = 1;
    $$self{nfold}        = '';
    $$self{snps}  = 
    {
        bad_sites    => q[-m+ -e'%QUAL<10 && RPB<0.1'],
        annots       => 'RPB,SGB,VDB,QUAL,MQSB,ICB',
        good_vcf     => '/lustre/scratch105/projects/g1k/ref/broad_resources_b37/hapmap_3.3.b37.sites.vcf.gz',
        override_bad => 1,
        nshuffle_max => 100_000,
        chunk_by     => 100,
        train_args   => '',
    };
    $$self{_sampleconf} = '';

    my $type = $class->filter_type(@ARGV);
    if ( $type eq 'som' ) { $self = SOM_Runner->new(%$self); }
    elsif ( $type eq 'svm' ) { $self = SVM_Runner->new(%$self); }

    $$self{_sampleconf} = q[
            # --------------------------------------
            # Parameters shared by all filter types
            # --------------------------------------

            chroms       => [ qw(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22) ],

            do_snps      => 1,
            do_indels    => 0,

            # Single VCF or a file with list of file names. Can be overriden by the -i command line argument.
            in_vcf       => undef,
            merge_files  => ] .$$self{merge_files}. q[,     # Set to 0 if files should be filtered separately

            snps => 
            {
                # The "bad_sites" filter is used to pre-filter the "in_vcf" file. IMPORTANT: this step
                #   defines bad sites in training. The sites failing this filter will be marked as bad,
                #   only sites with FILTER="PASS" or "." will be classified.
                bad_sites    => q\[] .$$self{snps}{bad_sites}. q[\],

                # The optional "good_sites" filter enables to further restrict "good_vcf" sites. When
                #   set, only sites present in "good_vcf" and passing the "good_sites" filter are used
                #   to define good sites in training.
                good_sites   => undef,

                # Annotations to select from. The pipeline will systematically try all combinations
                #   (up to the nshuffle_max limit) and select annotations which prove to be most
                #   successfull in distinguishing the good and bad training sites.
                annots       => '] .$$self{snps}{annots}. q[',

                # Defines good sites used in training.
                good_vcf     => '] .$$self{snps}{good_vcf}. q[',

                # How to resolve conflicting results when a good site (i.e. present in "good_vcf") is also
                #   marked as bad (i.e. failing the "bad_sites" filter): Mark these sites as bad (0), good (1),
                #   leave unclassified and let the classifier decide (2).
                override_bad => '] .$$self{snps}{override_bad}. q[',

                # Maximum number of annotation combinations to try
                nshuffle_max => '] .$$self{snps}{nshuffle_max} . q[',

                # Every single run is relatively fast, but there can be many combinations to test.
                #   Chunk multiple runs into one to prevent submission of too many short-running jobs.
                chunk_by     => '] .$$self{snps}{chunk_by} . q[',
                
                # Default parameters. SVM's -c and -g will be expanded to 2**c,2**g
                train_args   => '] .$$self{snps}{train_args} . q[',
            },

            # Maximum number of good and bad sites to train on (SVM can be slow)
            ngood_max   => ] .$$self{ngood_max}. q[,
            nbad_max    => ] .$$self{nbad_max}. q[,

            # If specified, populate each allele-frequency bin with the same number of training sites
            # af_bins     => [ 0.1, 1, 5 ],
            nfold       => '] .$$self{nfold} . q[',      # n-fold cross-validation
            random_seed => undef,      # random seed for selection training sites

            # Scale in this quantile range [%]
            scale_qlow   => '] . $$self{scale_qlow} . q[',
            scale_qhigh  => '] . $$self{scale_qhigh} . q[',
            qaccuracy    => '] . $$self{qaccuracy} . q[',    # throw if the quantile approximation is too inaccurate

            do_clean => 1, 

            # For sanity checking that your config file is not obsolete. Update the version key in your 
            #  config file to get rid of the warnings.
            version      => '] .$$self{config_version}. q[',
    ]."\n".$$self{_sampleconf}."\n";

    $$self{usage} .= 
        "Usage: run-filter [som|svm] [OPTIONS]\n" .
        "Options:\n" .
        "   -a, --annots <type:list>            Subset of annotations to use, e.g. snps:QUAL,RPB\n" .
        "   -A, --apply <expr>                  Apply filter to produce final VCF(s). If \"-\" is given, only MLQ annotation is added\n" .
        "   -C, --clean                         Clean all temporary files\n" .
        "   -c, --classify                      Classify\n" .
        "   -i, --input <vcf>                   Input VCF\n" .
        "   -m, --mrProper                      Clean all temporary files leaving only the resulting VCF\n" .
        "   -o, --outdir <dir>                  Output directory\n" .
        "   -p, --parameters <type:string>      Parameters to use, e.g. 'snps:-c 15 -g -3' (overrides train_args config key)\n" .
        "   -r, --randomize                     Randomly shuffle annotations to find the best combination\n" .
        "   -s, --scan                          Scan the parameter space to find the best values\n" .
        "   -t, --threshold <type:value>        Test the effects of MLQ threshold, e.g. 'snps:0.0568229'\n" .
        "The pipeline is usually run as:\n" .
        "   run-filter [som|svm] +config <file> -o <outdir>\n" .
        "Which automatically runs the following three steps:\n" .
        "   1) Search for best annotations\n" .
        "       run-filter som +config <file> -o <outdir> --randomize\n" .
        "   2) Search for best parameters\n" .
        "       run-filter som +config <file> -o <outdir> -a <annots> --scan\n" .
        "   3) Classify\n" .
        "       run-filter som +config <file> -o <outdir> -a <annots> -p <params> --classify\n" .
        "After this is done, proceed to select filtering threshold based on <outdir>/snps/result.tab*:\n" .
        "   4) Test the effect of the threshold\n" .
        "       run-filter som +config <file> -o <outdir> -t <type>:<value>\n" .
        "   5) Create final VCF with genotypes. The --apply expression is directly passed to `bcftools filter`\n" .
        "      as it is. The bad_sites fixed filter will not be applied unless explicitly added here, e.g.:\n" .
        "       run-filter som +config <file> -o <outdir> --apply '-m+ -e \"%QUAL<10 || (MLQ<0.0568229 & %TYPE=\\\"snp\\\")\"'\n" .
        "\n";

    return $self;
}

sub parse_args
{
    my ($self) = @_;
    my %action = ();
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq 'som' ) { next; }
        if ( $arg eq 'svm' ) { next; }
        if ( $arg eq '-t' or $arg eq '--threshold' ) { my ($type,$value)=split(/:/,shift(@ARGV)); $$self{threshold}{$type} = $value; $$self{test_threshold} = 1; next; }
        if ( $arg eq '-A' or $arg eq '--apply' ) { $$self{apply_threshold} = shift(@ARGV); next; }
        if ( $arg eq '-r' or $arg eq '--randomize' ) { $$self{randomize} = 1; $action{randomize} = 1; next; }
        if ( $arg eq '-s' or $arg eq '--scan' ) { $$self{scan} = 1; $action{scan} = 1; next; }
        if ( $arg eq '-c' or $arg eq '--classify' ) { $$self{classify} = 1; $action{classify} = 1; next; }
        if ( $arg eq '-p' or $arg eq '--parameters' ) 
        { 
            $arg = shift(@ARGV);
            my ($type,$args) = split(m{:}, $arg);
            if ( $type ne 'snps' && $type ne 'indels' ) { $self->throw("Could not parse: $arg"); }
            $$self{$type}{train_args} = $args; 
            next; 
        }
        if ( $arg eq '-a' or $arg eq '--annots' ) 
        { 
            $arg = shift(@ARGV);
            my ($type,$anns) = split(m{:}, $arg);
            if ( $type ne 'snps' && $type ne 'indels' ) { $self->throw("Could not parse: $arg"); }
            $$self{$type}{annots} = $anns;
            next; 
        }
        if ( $arg eq '-c' or $arg eq '--clean' ) { $$self{clean}=1; next; }
        if ( $arg eq '-o' or $arg eq '--outdir' ) { $$self{outdir}=shift(@ARGV); next; }
        if ( $arg eq '-i' or $arg eq '--input' ) { $$self{in_vcf}=shift(@ARGV); next; }
        if ( $arg eq '-m' or $arg eq '--mrProper' ) { $$self{mrProper}=1; next; }
        if ( $arg eq '-h' or $arg eq '-?' or $arg eq '--help' ) { $self->throw(); }
        $self->throw("Unknown parameter: $arg");
    }
    if ( scalar keys %action != 1 ) { $$self{auto} = 1; }
    $$self{types} = [];
    if ( $$self{do_snps} ) { push @{$$self{types}}, 'snps'; }
    if ( $$self{do_indels} ) { push @{$$self{types}}, 'indels'; }
    if ( !@{$$self{types}} ) { $self->throw("Neither do_snps nor do_indels key is set!\n"); }
    if ( exists($$self{version}) && $$self{version} ne $$self{config_version} )
    {
        $self->throw("Warning: Your config file may be out of date, the latest version key is \"$$self{config_version}\". Please run with +sampleconf to see what changed.\n");
    }
    for my $type (@{$$self{types}})
    {
        if ( !exists($$self{$type}{good_vcf}) ) { $self->throw("Expected '$type/good_vcf' parameter."); }
        $$self{$type}{annots} =~ s/\s+//;
        my @anns = split(/,/,$$self{$type}{annots});
        my %anns;
        for my $ann (@anns)
        {
            if ( exists($anns{$ann}) ) { $self->throw("Warning: The annotation \"$ann\" is present twice in the list: $$self{$type}{annots}\n"); }
            $anns{$ann} = 1;
        }
    }
    if ( exists($$self{apply_threshold}) ) { $$self{test_threshold} = 0; }
    if ( !defined($$self{in_vcf}) ) { $self->throw("Expected -i option."); }
    if ( $$self{clean} ) 
    { 
        # Run performance stats and clean
        $self->clean($$self{outdir});
        $self->all_done;
    }
    if ( $$self{mrProper} )
    {
        $self->mrProper($$self{outdir});
        $self->all_done;
    }
    $$self{outdir} =~ s{/+?$}{};
}

sub main
{
    my ($self) = @_;

    if ( ref($self) eq 'myRunner' ) { $self->parse_args(); $self->throw("Expected \"som\" or \"svm\".\n"); }

    my $outdir = $$self{outdir};

    # Create sites-only VCFs
    my @files = $self->get_file_list($$self{in_vcf});
    for my $file (@files)
    {
        for my $type (@{$$self{types}})
        {
            $self->spawn('strip_genotypes',"$outdir/$type/sites/$$file{bname}.bcf",$$file{file},$type);
        }
    }
    $self->wait;

    # Extract annotations
    my %tmp;
    for my $file (@files)
    {
        for my $type (@{$$self{types}})
        {
            $self->spawn('extract_annots',"$outdir/$type/annots/$$file{bname}.annots.tab","$outdir/$type/sites/$$file{bname}.bcf",$type);
            push @{$tmp{$type}}, "$outdir/$type/annots/$$file{bname}.annots.tab";
        }
    }
    $self->wait;

    my @jobs = ();
    for my $type (@{$$self{types}})
    {
        if ( $$self{merge_files} )
        {
            $self->spawn('scale_annots',"$outdir/$type/merged/annots.tab",$type,@{$tmp{$type}});
            @jobs = ('merged');
        }
        else
        {
            for my $file (@files)
            {
                $self->spawn('scale_annots',"$outdir/$type/$$file{bname}/annots.tab",$type,"$outdir/$type/annots/$$file{bname}.annots.tab");
                push @jobs, $$file{bname};
            }
        }
    }
    $self->wait;
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $self->sanity_check_scaling("$outdir/$type/$job/annots.tab");
            $self->sanity_check_annots("$outdir/$type/$job/annots.tab",$type,$$self{$type}{annots},$job);
        }
    }

    if ( $$self{randomize} or $$self{auto} )
    {
        $self->main_randomize(@jobs);
    }
    if ( $$self{scan} or $$self{auto} )
    {
        $self->main_scan_params(@jobs);
    }
    if ( $$self{classify} or $$self{auto} )
    {
        $self->main_classify(@jobs);
    }
    if ( $$self{test_threshold} )
    {
        $self->main_test_threshold();
    }
    if ( exists($$self{apply_threshold}) )
    {
        $self->main_apply_threshold();
    }

    # Run performance stats and clean
    $self->spawn('runtime_stats',"$outdir/runtime");
    $self->wait;
    $self->clean($outdir) unless !$$self{do_clean};

    $self->all_done;
}
sub main_randomize
{
    my ($self,@jobs) = @_;
    my %files;
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            my $finished = $self->is_finished("$$self{outdir}/$type/$job/randomize.tab") ? 1 : 0;

            my @annots  = split(/,/,$$self{$type}{annots});
            my $nannots = scalar @annots;
            my $cmbs  = $self->shuffle($$self{$type}{nshuffle_max}, $nannots);
            for (my $i=0; $i<@$cmbs; $i+=$$self{$type}{chunk_by})
            {
                my @test_annots;
                for (my $j=0; $j<$$self{$type}{chunk_by}; $j++)
                {
                    if ( $i+$j >= @$cmbs ) { last; }
                    my @anns;
                    for (my $k=0; $k<@annots; $k++)
                    {
                        if ( $$cmbs[$i+$j] & (1<<$k) ) { next; }
                        push @anns, $k;
                    }
                    if ( !@anns ) { next; }
                    push @test_annots, \@anns;
                }
                push @{$files{$type}{$job}} , "$$self{outdir}/$type/$job/randomize/$i.tab";
                if ( $finished ) { next; }
                $self->spawn('randomized_test',"$$self{outdir}/$type/$job/randomize/$i.tab", "$$self{outdir}/$type/$job/annots.train", $type, @test_annots);
            }
        }
    }
    $self->wait;
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $self->spawn('randomized_test_merge',"$$self{outdir}/$type/$job/randomize.tab", $files{$type}{$job});
        }
    }
    $self->wait;
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $self->spawn('randomized_test_eval',"$$self{outdir}/$type/$job/randomize.tab.eval", "$$self{outdir}/$type/$job/randomize.tab", $$self{$type}{annots});
        }
    }
    $self->wait;
}
sub main_scan_params
{
    my ($self,@jobs) = @_;

    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $self->spawn('subset_train_file',$$self{$type}{$job}{train_fname},"$$self{outdir}/$type/$job/annots.train",$$self{$type}{$job}{cols});
        }
    }
    $self->wait;

    my %best = ();
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $best{$type}{$job} = "$$self{outdir}/$type/$job/scan.$$self{aopt}.$$self{bopt}$$self{$type}{$job}{suffix}";
        }
    }

    my %tmp  = ();
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            if ( $self->is_finished("$best{$type}{$job}.tab") ) { next; }
            my @sjobs = $self->scan_params_jobs($type,$job);
            for my $sjob (@sjobs)
            {
                my $outfile = "$$self{outdir}/$type/$job/scan$$self{$type}{$job}{suffix}/$$sjob{prefix}.tab";
                push @{$tmp{$type}{$job}}, { file=>$outfile, apar=>$$sjob{apar}, bpar=>$$sjob{bpar} };
                $self->spawn('scan_params_test',$outfile,$$self{$type}{$job}{train_fname},$$sjob{args});
            }
        }
    }
    $self->wait;

    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            if ( $self->is_finished("$best{$type}{$job}.tab") ) { next; }
            $self->spawn('scan_params_merge',"$$self{outdir}/$type/$job/scan.$$self{aopt}.$$self{bopt}$$self{$type}{$job}{suffix}.tab",@{$tmp{$type}{$job}});
        }
    }
    $self->wait;
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            my $fname = "$$self{outdir}/$type/$job/scan.$$self{aopt}.$$self{bopt}$$self{$type}{$job}{suffix}.tab";
            my $params;
            if ( $$self{auto} )
            {
                my @args = $self->read_value($fname,qr/\t/,0);
                chomp($args[-1]);
                $params  = $self->strip_cmdline_args($$self{$type}{train_args}, "-$$self{aopt}", "-$$self{bopt}");
                $params .= " -$$self{aopt} $args[1] -$$self{bopt} $args[2]";
            }
            else 
            { 
                $params = $$self{$type}{train_args};
            }
            $$self{$type}{$job}{train_args} = $self->expand_train_args($params);
            $self->spawn('scan_params_plot',"$best{$type}{$job}.py",$fname);
        }
    }
    $self->wait;
}
sub main_classify
{
    my ($self,@jobs) = @_;

    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            $self->spawn('subset_train_file',$$self{$type}{$job}{train_fname},"$$self{outdir}/$type/$job/annots.train",$$self{$type}{$job}{cols});
            $self->spawn('subset_train_file',$$self{$type}{$job}{annots_fname},"$$self{outdir}/$type/$job/annots.tab",$$self{$type}{$job}{cols});
        }
    }
    $self->wait;

    my %tmp = ();
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            my $name = $$self{$type}{$job}{train_args}; $name =~ s/\s+//g; $name =~ s/^-//; $name .= $$self{$type}{$job}{suffix};
            $tmp{$type}{$job} = $name;
            $self->spawn('classify',"$$self{outdir}/$type/$job/classify.$name",$$self{$type}{$job}{train_fname},$$self{$type}{$job}{annots_fname},$$self{$type}{$job}{train_args});
        }
    }
    $self->wait;

    my %tmp2 = ();
    for my $type (@{$$self{types}})
    {
        for my $job (@jobs)
        {
            my $outfile = "$$self{outdir}/$type/$job/classify.$tmp{$type}{$job}.tab";
            push @{$tmp2{$type}}, $outfile;
            $self->spawn('classify_eval',$outfile,"$$self{outdir}/$type/$job/classify.$tmp{$type}{$job}/scores.tab","$$self{outdir}/$type/$job/annots.sites.gz");
        }
    }
    $self->wait;

    for my $type (@{$$self{types}})
    {
        $self->spawn('classify_merge',"$$self{outdir}/$type/result.tab",@{$tmp2{$type}});
    }
    $self->wait;

    my @files = $self->get_file_list($$self{in_vcf});
    for my $type (@{$$self{types}})
    {
        for my $file (@files)
        {
            $self->spawn('annotate_scores',"$$self{outdir}/$type/scored/$$file{bname}.vcf.gz","$$self{outdir}/$type/sites/$$file{bname}.bcf",@{$tmp2{$type}});
        }
    }
    $self->wait;
}
sub main_test_threshold
{
    my ($self) = @_;
    for my $type (@{$$self{types}})
    {
        my @files;
        opendir(my $dh,"$$self{outdir}/$type/scored") or $self->throw("$$self{outdir}/$type/scored: $!");
        while (my $file = readdir $dh) 
        {
            if ( $file=~/\.vcf\.gz$/ or $file=~/\.bcf$/ ) { push @files, $file; }
        }
        closedir $dh;

        my $th = $$self{threshold}{$type};
        for my $file (@files)
        {
            my $out = $file;
            $out =~ s/\.vcf.gz$/.bcf/;
            $self->spawn('apply_threshold',"$$self{outdir}/$type/test-$type-$th/$out","$$self{outdir}/$type/scored/$file",qq[-Ob -i'MLQ>=$th']);
        }
        $self->wait;

        if ( !$self->is_finished("$$self{outdir}/$type/test-$type-$th.stats") )
        {
            $self->merge_stats("$$self{outdir}/$type/test-$type-$th.stats","$$self{outdir}/$type/test-$type-$th/*.stats");
        }
    }
}
sub main_apply_threshold
{
    my ($self) = @_;
    my @files;
    for my $type (@{$$self{types}})
    {
        opendir(my $dh,"$$self{outdir}/$type/scored") or $self->throw("$$self{outdir}/$type/scored: $!");
        while (my $file = readdir $dh)
        {
            if ( $file=~/\.vcf\.gz$/ or $file=~/\.bcf$/ ) { push @files, "$$self{outdir}/$type/scored/$file"; }
        }
        closedir $dh;
    }
    $self->spawn('create_mlq_tab',"$$self{outdir}/MLQ.tab.gz",@files);
    $self->wait;

    @files = $self->get_file_list($$self{in_vcf});
    for my $file (@files)
    {
        $self->spawn('apply_mlq_tab',"$$self{outdir}/final-vcfs/$$file{bname}.vcf.gz","$$self{outdir}/MLQ.tab.gz",$$file{file});
    }
    $self->wait;

}

sub apply_threshold
{
    my ($self,$outfile,$infile,$opts) = @_;
    $self->cmd("$$self{bcftools} filter $opts $infile > $outfile.part");
    $self->cmd("$$self{bcftools} stats $outfile.part > $outfile.stats");
    $self->tabix_part($outfile);
}
sub merge_stats
{
    my ($self,$outfile,$infiles) = @_;
    $self->cmd("$$self{plot_stats} -m $infiles > $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}
sub create_mlq_tab
{
    my ($self,$outfile,@files) = @_;
    open(my $fh,'>',"$outfile.list") or $self->throw("$outfile.list: $!");
    for my $file (@files) { print $fh "$file\n"; }
    close($fh) or $self->throw("close $outfile.list");
    $self->cmd(qq[$$self{bcftools} query -f'\%CHROM\\t\%POS\\t\%REF\\t\%ALT\\t\%MLQ\\n' -v $outfile.list | sort -k1,1 -k2,2n | bgzip -c > $outfile.part]); 
    $self->cmd(qq[$$self{bcftools} tabix -s1 -b2 -e2 $outfile.part]);
    rename("$outfile.part.tbi","$outfile.tbi");
    rename("$outfile.part",$outfile);
}
sub apply_mlq_tab
{
    my ($self,$outfile,$mlq,$infile) = @_;
    my $cmd = 
        qq[$$self{bcftools} view $infile] .
        qq[| $$self{bcftools} annotate -a $mlq -h $outfile.hdr -c CHROM,POS,REF,ALT,MLQ];

    open(my $fh,'>',"$outfile.hdr") or $self->throw("$outfile.hdr: $!");
    print $fh qq[##INFO=<ID=MLQ,Number=1,Type=Float,Description="Machine Learning Quality Score">\n];
    close($fh) or $self->throw("close failed: $outfile.hdr");

    if ( $$self{apply_threshold} ne '-' )
    {
        $cmd .= qq[ -Ou | $$self{bcftools} filter $$self{apply_threshold}];
    }
    $self->cmd($cmd . qq[ -Oz > $outfile.part]);
    unlink("$outfile.hdr");
    $self->cmd(qq[$$self{bcftools} stats $outfile.part > $outfile.stats]);
    $self->tabix_part($outfile);
}

sub sanity_check_annots
{
    my ($self,$anns_tab,$type,$anns,$job) = @_;

    if ( $$self{auto} )     # automatic selection of annotations and parameters
    {
        if ( $self->is_finished("$$self{outdir}/$type/$job/randomize.tab") )
        {
            my @anns = $self->read_value("$$self{outdir}/$type/$job/randomize.tab",qr/\t/,0);
            shift(@anns);
            chomp($anns[-1]);
            $anns = join(',',@anns);
        }
    }
    my $saved_anns = $self->read_value("$anns_tab.anns",qr/\t/,0,0);
    my @saved = split(/,/,$saved_anns);
    my %cols;
    for (my $i=0; $i<@saved; $i++) { $cols{$saved[$i]} = $i; }
    my @new_anns = split(/,/,$anns);
    for my $ann (@new_anns)
    {
        if ( !exists($cols{$ann}) )
        {
            $self->throw("Error: Annotations mismatch. Existing files were generated for $saved_anns, which does not contain $ann\n");
        }
        $$self{$type}{$job}{cols}{$ann} = $cols{$ann};
    }
    if ( $saved_anns eq $anns )
    {
        $$self{$type}{$job}{suffix} = '';
    }
    else
    {
        $$self{$type}{$job}{suffix} = '.' . join('-',sort @new_anns);
        $$self{$type}{$job}{suffix} =~ s/[{}]//g;
    }
    $$self{$type}{$job}{train_fname}  = "$$self{outdir}/$type/$job/annots.train$$self{$type}{$job}{suffix}";
    $$self{$type}{$job}{annots_fname} = "$$self{outdir}/$type/$job/annots.tab$$self{$type}{$job}{suffix}";
}

sub shuffle
{
    my ($self, $nmax, $n) = @_;

    # variable number of nested loops
    my (@out, @cnt);
    my ($il, $nl);

    my $i = 0;
    for ($il=0; $il<$n; $il++) { $out[$i] |= 1<<$i; }   # add all (11111)
    $i++;

    for ($nl=$n-1; $nl>=1; $nl--)       # the case 0000 not considered, starting from 00001
    {
        for ($il=0; $il<$nl-1; $il++) { $cnt[$il] = 0; }
        $cnt[$nl-1] = -1;
        while (1)
        {
            for ($il=$nl-1; $il>=0; $il--)
            {
                if ( ++$cnt[$il] < $n-$nl+$il+1 ) { last; }
                if ( $il==0 ) { last; }
                $cnt[$il] = 0;
            }
            for ($il=1; $il<$nl; $il++)
            {
                if ( $cnt[$il] <= $cnt[$il-1] ) { $cnt[$il] = $cnt[$il-1] + 1; }
            }

            if ( $cnt[$nl-1] >= $n ) { last; }

            for ($il=0; $il<$nl; $il++) { $out[$i] |= 1<<$cnt[$il]; }
            if ( ++$i >= $nmax ) { last; }
        }
        if ( $i >= $nmax ) { last; }
    }
    return \@out;
}

sub parse_file_name
{
    my ($self,$fname,$chr) = @_;
    $fname =~ s/{CHROM}/$chr/g;
    if ( ! -e $fname ) { $self->throw("The file \"$fname\" does not exist\n"); }
    return $fname;
}
sub is_file_list
{
    my ($self,$file) = @_;
    my @out = `file $file`;
    if ( $out[0]=~/ASCII/ ) { return 1; }
    return 0;
}
sub strip_dir
{
    my ($self,$file) = @_;
    $file =~ s{^.*/}{};
    return $file;
}
sub get_file_list
{
    my ($self,$file) = @_;
    my @files;
    if ( $self->is_file_list($file) )
    {
        open(my $fh,'<',$file) or $self->throw("$file: $!");
        while (my $line=<$fh>)
        {
            chomp($line);
            $line =~ s/^\s*//;
            $line =~ s/\s*$//;
            push @files, $line;
        }
        close($fh);
    }
    else
    {
        my %files = ();
        for my $chr (@{$$self{chroms}}) { my $file = $self->parse_file_name($file,$chr); $files{$file} = 1; }
        @files = sort keys %files;
    }

    my @out;
    my %names;
    for my $fname (@files)
    {
        my $bname = $self->strip_dir($fname);
        $bname  =~ s/.vcf.gz$//;
        $bname  =~ s/.vcf$//;
        $bname  =~ s/.bcf$//;
        my $tmp = $bname;
        my $i = 0;
        while ( exists($names{$tmp}) ) { $tmp = $bname.(++$i); }
        push @out, { file=>$fname, bname=>$tmp };
        $names{$tmp} = 1;
    }
    return (@out);
}

# strip genotypes and annotate bad sites
sub strip_genotypes
{
    my ($self,$outfile,$infile,$type) = @_;
    $self->cmd("$$self{bcftools} view -G -Ou $infile -i '%TYPE=\"$type\"' | $$self{bcftools} filter -s BadSite $$self{$type}{bad_sites} -Ob - > $outfile.part");
    $self->cmd("$$self{bcftools} index $outfile.part");
    rename("$outfile.part.csi","$outfile.csi") or $self->throw("rename: $outfile.part.csi $outfile.csi: $!");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile: $!");
}

sub extract_annots
{
    my ($self,$outfile,$infile,$type) = @_;

    my $good_vcf = $$self{$type}{good_vcf};
    if ( defined $$self{$type}{good_sites} )
    {
        my $tmpfile = $infile;
        $tmpfile  =~ s/\.bcf$//i;
        $tmpfile .= '.good.bcf';
        $self->cmd("$$self{bcftools} isec -c both -n=2 -w1 $infile $good_vcf -Ou | $$self{bcftools} filter $$self{$type}{good_sites} -Ob - > $tmpfile");
        $self->cmd("$$self{bcftools} index $tmpfile");
        $good_vcf = $tmpfile;
    }

    my @anns = split(/,/,$$self{$type}{annots});
    my $anns = '%CHROM\t%POS\t%REF\t%ALT\t%FILTER\t%MASK\t%AC\t%AN\t%' . join('\t%', @anns) . '\n';
    my $cmd  = "$$self{bcftools} query -c both -f'$anns' $infile $good_vcf";

    print STDERR "$cmd\n";
    open(my $in,"$cmd |") or $self->throw("$cmd: $!");

    open(my $out,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $out "# [1]CHROM\t[2]POS\t[3]IS_TS\t[4]CLASS (unclassified:0, good:$$self{good_site}, bad:$$self{bad_site})\t[5]AF";
    for (my $i=0; $i<@anns; $i++) { printf $out "\t[%d]%s", $i+6,$anns[$i]; } 
    print $out "\n";
    while (my $line=<$in>)
    {
        my ($chr,$pos,$ref,$alt,$flt,$mask,$ac,$an,@vals) = split(/\t/,$line);
        $ref = lc($ref);
        $alt = lc($alt);
        $alt =~ s/,.*//;
        if ( length($ref)>1 or length($alt)>1 ) { $self->throw("todo: $chr,$pos,$ref,$alt\n"); }

        my $is_ts = 0;
        if ( $ref eq 'c' and $alt eq 't' or $ref eq 't' and $alt eq 'c' ) { $is_ts = 1; }
        elsif ( $ref eq 'a' and $alt eq 'g' or $ref eq 'g' and $alt eq 'a' ) { $is_ts = 1; }

        my $is_good = 0;
        for (my $i=1; $i<length($mask); $i++)
        {
            if ( substr($mask,$i,1) eq '1' ) { $is_good = 1; last; }
        }
        
        my $class = 0;  # unclassified
        if ( $flt eq 'PASS' or $flt eq '.' ) 
        { 
            if ( $is_good ) { $class = $$self{good_site}; }
        }
        elsif ( !$is_good ) { $class = $$self{bad_site}; }
        elsif ( !$$self{$type}{override_bad} ) { $class = $$self{bad_site}; }
        elsif ( $$self{$type}{override_bad}==1 ) { $class = $$self{good_site}; }

        my $af = sprintf "%.2f", $ac*100./$an;
        print $out "$chr\t$pos\t$is_ts\t$class\t$af\t", join("\t",@vals);
    }
    close($in) or $self->throw("close failed: $cmd");
    close($out) or $self->throw("close failed: $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub af_to_bin
{
    my ($self,$af) = @_;
    if ( !exists($$self{af_bins}) ) { return 0; }
    for (my $i=0; $i<@{$$self{af_bins}}; $i++)
    {
        if ( $af<$$self{af_bins}[$i] ) { return $i; }
    }
    return scalar @{$$self{af_bins}};
}

sub scale_annots
{
    my ($self,$outfile,$type,@files) = @_;

    if ( defined $$self{random_seed} ) { srand($$self{random_seed}); }

    my $sites_fname  = $outfile;
    my $scale_fname  = $outfile;
    my $train_fname  = $outfile;
    my $af_bin_fname = $outfile;
    $sites_fname  =~ s/.tab$/.sites.gz/;
    $scale_fname  =~ s/.tab$/.scale/;
    $train_fname  =~ s/.tab$/.train/;
    $af_bin_fname =~ s/.tab$/.af/;

    open(my $fh,'>',"$outfile.anns") or $self->throw("$outfile.anns: $!");
    print $fh $$self{$type}{annots},"\n";
    close($fh) or $self->throw("close fail: $outfile.anns");

    my @anns = split(/,/,$$self{$type}{annots});
    my @quests = ();
    for my $ann (@anns) { push @quests, Quantile->new(); }
    my $RE_FLOAT = qr/\-?\d+\.?\d*(?:[eE][+-]\d+)?/;
    my @ngood = ();
    my @nbad  = ();
    my @ntot  = ();
    my @extremes = ();

    # Read all values, extract chr,pos,is_ts,class and write for later evaluation.
    # Estimate quantiles for scaling.
    #
    open(my $fh_sites,"| bgzip -c > $sites_fname") or $self->throw("bgzip -c > $sites_fname: $!");
    for my $file (@files)
    {
        open(my $in,'<',$file) or $self->throw("$file: $!");
        while (my $line=<$in>)
        {
            if ( substr($line,0,1) eq '#' ) { next; }
            my ($chr,$pos,$is_ts,$class,$af,@vals) = split(/\t/,$line);
            chomp($vals[-1]);
            my $af_bin = $self->af_to_bin($af);

            if ( $class==$$self{bad_site} ) { $nbad[$af_bin]++; }
            elsif ( $class==$$self{good_site} ) { $ngood[$af_bin]++; }
            for (my $i=0; $i<@vals; $i++)
            {
                if ( !($vals[$i]=~$RE_FLOAT) ) { next; }        # missing values do not contribute to scaling as defaults
                $quests[$i]->add($vals[$i]);
                if ( !exists($extremes[$i]) or $extremes[$i][0] > $vals[$i] ) { $extremes[$i][0] = $vals[$i]; }
                if ( !exists($extremes[$i]) or $extremes[$i][1] < $vals[$i] ) { $extremes[$i][1] = $vals[$i]; }
            }
            print $fh_sites "$chr\t$pos\t$class\t$is_ts\n";
            $ntot[$af_bin]++;
        }
        close($in) or $self->throw("close failed: $file");
    }
    close($fh_sites) or $self->throw("close failed: $sites_fname");

    my @ngood_skip = ();
    my @nbad_skip  = ();
    my $ngood_max  = int($$self{ngood_max} / @ntot);
    my $nbad_max   = int($$self{nbad_max} / @ntot);
    my $ntot = 0;
    for (my $i=0; $i<@ntot; $i++)
    {
        $ngood_skip[$i] = $ngood[$i] && $ngood[$i] > $ngood_max ? $ngood[$i] - $ngood_max : 0;
        $nbad_skip[$i]  = $nbad[$i] && $nbad[$i] > $nbad_max ? $nbad[$i] - $nbad_max : 0;
        $ntot += $ntot[$i];
    }

    # Collect some stats
    my @bins = exists($$self{af_bins}) ? (@{$$self{af_bins}}) : ('100');
    my @ntrain_str = ();
    for (my $i=0; $i<@bins; $i++) { $ntrain_str[$i] = "$i\t$bins[$i]\t$ngood[$i]\t$nbad[$i]"; }
    my @ngood_train = ();
    my @nbad_train  = ();

    # Collect the quantiles
    my @margins = ();
    for (my $i=0; $i<@anns; $i++)
    {
        my $min = $quests[$i]->report($$self{scale_qlow}/100.);
        my $max = $quests[$i]->report($$self{scale_qhigh}/100.);
        push @margins, [$min,$max];
    }

    # Scale and write the annots file
    open(my $fh_out,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    open(my $fh_train,'>',$train_fname) or $self->throw("$train_fname: $!");
    my @nout = ();
    for my $file (@files)
    {
        open(my $in,'<',$file) or $self->throw("$file: $!");
        while (my $line=<$in>)
        {
            if ( substr($line,0,1) eq '#' ) { next; }
            my ($chr,$pos,$is_ts,$class,$af,@vals) = split(/\t/,$line);
            chomp($vals[-1]);

            for (my $i=0; $i<@vals; $i++)
            {
                if ( !($vals[$i]=~$RE_FLOAT) ) { $vals[$i] = undef; next; }
                if ( $vals[$i] < $margins[$i][0] ) { $vals[$i] = $margins[$i][0]; $nout[$i]++; }
                elsif ( $vals[$i] > $margins[$i][1] ) { $vals[$i] = $margins[$i][1]; $nout[$i]++; }
                $vals[$i] = ($vals[$i] - $margins[$i][0]) / ($margins[$i][1] - $margins[$i][0]);
            }
            my @out = ($class);
            push @out, $self->format_values(\@anns, @vals);
            print $fh_out join("\t",@out),"\n";

            my $af_bin = $self->af_to_bin($af);
            my $skip = 1;
            if ( $class==$$self{good_site} )
            {
                if ( !$ngood_skip[$af_bin] ) { $skip = 0; } 
                elsif ( rand(1) > $ngood_skip[$af_bin]/$ngood[$af_bin] ) { $skip = 0; }
                else { $ngood_skip[$af_bin]--; }
                $ngood[$af_bin]--;
            }
            elsif ( $class==$$self{bad_site} )
            {
                if ( !$nbad_skip[$af_bin] ) { $skip = 0; } 
                elsif ( rand(1) > $nbad_skip[$af_bin]/$nbad[$af_bin] ) { $skip = 0; }
                else { $nbad_skip[$af_bin]--; }
                $nbad[$af_bin]--;
            }
            if ( !$skip ) 
            { 
                print $fh_train join("\t",@out),"\n";
                if ( $class==$$self{good_site} ) { $ngood_train[$af_bin]++; }
                else { $nbad_train[$af_bin]++; }
            }
        }
        close($in) or $self->throw("close failed: $file");
    }
    close($fh_train) or $self->throw("close failed: $train_fname");
    close($fh_out) or $self->throw("close failed: $outfile.part");

    # Write the quantiles
    open($fh,'>',$scale_fname) or $self->throw("$scale_fname: $!");
    print $fh "# [1]Annotation\t[2]Min\t[3]Max\t[4]$$self{scale_qlow} quantile\t[5]$$self{scale_qhigh} quantile\t[6]\%Trimmed\n";
    for (my $i=0; $i<@anns; $i++)
    {
        if ( !exists($nout[$i]) ) { $nout[$i] = 0 ; }
        printf $fh "$anns[$i]\t$extremes[$i][0]\t$extremes[$i][1]\t$margins[$i][0]\t$margins[$i][1]\t%.4f\n", 100.*$nout[$i]/$ntot;
    }
    close($fh) or $self->throw("close failed: $scale_fname");

    # Write number of training sites in individual AF bins
    open($fh,'>',$af_bin_fname) or $self->throw("$af_bin_fname: $!");
    print $fh "# [1]AF bin\t[2]AF\t[3]Good sites\t[4]Bad sites\t[5]Good training sites\t[6]Bad training sites\n";
    for (my $i=0; $i<@bins; $i++) 
    { 
        if ( !$ngood_train[$i] ) { $ngood_train[$i] = 0; }
        if ( !$nbad_train[$i] ) { $nbad_train[$i] = 0; }
        print $fh $ntrain_str[$i] . "\t$ngood_train[$i]\t$nbad_train[$i]\n";
    }
    close($fh) or $self->throw("close failed: $scale_fname");

    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub sanity_check_scaling
{
    my ($self,$file) = @_;
    $file =~ s/\.tab$/.scale/;
    my @out = ();
    open(my $fh,'<',$file) or $self->throw("$file: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/^#/ ) { next; }
        my @items = split(/\t/,$line);
        if ( 100-$items[-1] < $$self{qaccuracy} ) { push @out, "\t$items[0]\t .. $items[-1]"; }
    }
    close($fh) or $self->throw("close failed: $file");
    if ( scalar @out )
    {
        $self->throw(
                "Too many out-of-range values detected in some annotations: $file\n" .
                "Did the quantile approximation failed or is the cutoff $$self{qaccuracy}\% too strict??\n" .
                join('', @out) . "\n" );

    }
}

sub randomized_test
{
    my ($self,$outfile,$train_file,$type,@cmbs) = @_;
    my $annots = $$self{$type}{annots};
    my @annots = split(/,/,$annots);
    open(my $fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    for my $cmb (@cmbs)
    {
        my %ann2col = ();
        for my $i (@$cmb) { $ann2col{$annots[$i]} = $i; }
        $self->subset_train_file("$outfile.train",$train_file,\%ann2col);
        my $score = $self->train("$outfile.train",$$self{$type}{train_args});
        print $fh $score;
        for my $i (@$cmb) { print $fh "\t", $annots[$i]; }
        print $fh "\n";
    }
    close($fh) or $self->throw("close failed: $outfile.part");
    unlink("$outfile.train");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub randomized_test_merge
{
    my ($self,$outfile,$files) = @_;
    open(my $fh,"| sort -k1,1gr > $outfile.part") or $self->throw("sort -k1,1gr > $outfile.part: $!");
    for my $file (@$files)
    {
        open(my $in,'<',$file) or $self->throw("$file: $!");
        while (my $line=<$in>) { print $fh $line; }
        close($in) or $self->throw("close failed: $file");
    }
    close($fh) or $self->throw("close failed: sort -k1,1gr > $outfile.part");
    for my $file (@$files) { unlink($file); }
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub randomized_test_eval
{
    my ($self,$outfile,$infile,$annots) = @_;
    my @anns = split(/,/,$annots);
    my (%present,%absent);
    open(my $fh,'<',$infile) or $self->throw("$infile: $!");
    while (my $line=<$fh>)
    {
        my ($accuracy,@vals) = split(/\t/,$line);
        chomp($vals[-1]);
        my %had_ann = map { $_=>1 } @vals;
        for my $ann (@anns)
        {
            if ( $had_ann{$ann} ) { push @{$present{$ann}}, $accuracy; }
            else { push @{$absent{$ann}}, $accuracy; }
        }
    }
    close($fh) or $self->throw("close failed: $infile");

    my %keep = ();
    my @out;
    for my $ann (@anns)
    {
        my ($p_val,$u_present,$u_absent) = MannWhitney->Utest($present{$ann},$absent{$ann});
        my $outcome = 'no    ';
        if ( $p_val>0.05 ) { $outcome = 'unsure'; }
        elsif ( $u_present > $u_absent ) { $outcome = 'yes   '; $keep{$ann} = 1; }
        my $line = sprintf "$outcome\t%.6f\t%d\t%d\t$ann\n", $p_val,$u_present,$u_absent;
        push @out, { line=>$line, u=>$u_present, outcome=>$outcome };
    }
    @out = sort {
        if ( $$b{outcome} cmp $$a{outcome} ) { return $$b{outcome} cmp $$a{outcome}; }
        return $$b{u}<=>$$a{u};
    } @out;

    open($fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $fh "# [1]Is useful\t[2]P-value (smaller is more significant)\t[3]U-present\t[4]U-absent\t[5]Annotation\n";
    for my $rec (@out) { print $fh $$rec{line}; }
    close($fh);

    open($fh,'<',$infile) or $self->throw("$infile: $!");
    open(my $out,'>',"$infile.stripped") or $self->throw("$infile.stripped: $!");
    while (my $line=<$fh>)
    {
        my @items = split(/\t/,$line);
        chomp($items[-1]);
        my $skip = 0;
        for (my $i=1; $i<@items; $i++) 
        {
            if ( $keep{$items[$i]} ) { next; }
            $skip = 1; last;
        }
        if ( !$skip ) { print $out $line; }
    }
    close($fh) or $self->throw("close failed: $infile");
    close($out) or $self->throw("close failed: $infile.stripped");

    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub subset_train_file
{
    my ($self,$outfile,$train_file,$ann2col) = @_;
    my %col2ann = ();
    while (my ($ann,$col) = each %$ann2col) { $col2ann{$col} = $ann; }
    open(my $in,'<',$train_file) or $self->throw("$train_file: $!");
    open(my $out,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    while (my $line=<$in>)
    {
        my ($class,@vals) = split(/\t/,$line);
        chomp($vals[-1]);
        @vals = $self->strip_values(\%col2ann,@vals);
        print $out join("\t",$class,@vals),"\n";
    }
    close($in) or $self->throw("close failed: $train_file");
    close($out) or $self->throw("close failed: $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub scan_params_merge
{
    my ($self,$outfile,@files) = @_;
    open(my $out,"| sort -k1,1gr > $outfile.part") or $self->throw("sort -k1,1gr > $outfile.part: $!");
    for my $file (@files)
    {
        open(my $fh,'<',$$file{file}) or $self->throw("$$file{$file}: $!");
        my @val = <$fh>;
        close($fh) or $self->throw("close failed: $$file{file}");
        chomp($val[0]);
        print $out "$val[0]\t$$file{apar}\t$$file{bpar}\n";
    }
    close($out) or $self->throw("close failed: $outfile.part");
    for my $file (@files) { unlink($$file{file}); }

    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub scan_params_plot
{
    my ($self,$outfile,$file) = @_;
    my %best = ();
    my @dat;
    my %taken = ();
    my $navals = 0;
    my $nbvals = 0;
    open(my $fh,'<',$file) or $self->throw("$file: $!");
    while (my $line=<$fh>)
    {
        my ($accuracy,$a,$b) = split(/\t/,$line);
        chomp($b);
        my $ia = sprintf "%.0f", ($a-$$self{apar}[0])/$$self{apar}[2];
        my $ib = sprintf "%.0f", ($b-$$self{bpar}[0])/$$self{bpar}[2];
        if ( exists($taken{$ia.':'.$ib}) ) { $self->throw("Uh: $ia,$ib .. $a,$b (int(($a-$$self{apar}[0])/$$self{apar}[2]) and int(($b-$$self{bpar}[0])/$$self{bpar}[2]))\n"); }
        $taken{$ia.':'.$ib} = 1;
        if ( $navals < $ia ) { $navals = $ia; }
        if ( $nbvals < $ib ) { $nbvals = $ib; }
        push @dat, "Z[$ia][$ib] = $accuracy";
        if ( !%best or $best{accuracy} < $accuracy ) { $best{accuracy} = $accuracy; $best{apar} = $a; $best{bpar} = $b; }
    }
    close($fh) or $self->throw("close failed: $file");

    $navals++;
    $nbvals++;
    my $zvals  = join("\n", @dat);
    my $title  = "$$self{aopt}=$best{apar}, $$self{bopt}=$best{bpar},\\naccuracy $best{accuracy}%";

    my $plot = $outfile;
    $plot =~ s/.py//;
    open($fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    $self->tprint($fh,"
        import matplotlib as mpl
        mpl.use('Agg')
        import matplotlib.pyplot as plt
        import numpy as np

        Z = [[0 for tmp in xrange($nbvals)] for tmp in xrange($navals)]
        $zvals

        fig, ax = plt.subplots(1,1)
        im = plt.imshow(Z,interpolation='none',extent=[$$self{bpar}[0],$$self{bpar}[1],$$self{apar}[0],$$self{apar}[1]],origin='lower',aspect='auto')
        cb = plt.colorbar(im)
        ax.set_xlabel('$$self{bopt}')
        ax.set_ylabel('$$self{aopt}')
        ax.set_title('$title')
        plt.savefig('$plot.png')
        plt.close()
    ");
    close($fh) or $self->throw("close failed: $outfile.part");
    $self->cmd("python $outfile.part");
    
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub classify_eval
{
    my ($self,$outfile,$score_file,$sites_file) = @_;
    open(my $score_fh,'<',$score_file) or $self->throw("$score_file: $!");
    open(my $sites_fh,"gunzip -c $sites_file|") or $self->throw("gunzip -c $sites_file: $!");
    open(my $fh,"|sort -k1,1gr > $outfile.tmp") or $self->throw("sort -k1,1gr > $outfile.tmp: $!");
    open(my $gz,"|bgzip -c > $outfile.sites.gz") or $self->throw("bgzip -c > $outfile.sites.gz: $!");
    my $ngood_sites = 0;
    my $ntot_sites  = 0;
    while (1)
    {
        my $score_line = <$score_fh>;
        my $sites_line = <$sites_fh>;
        if ( !defined $score_line && !defined $sites_line ) { last; }
        if ( !defined $score_line or !defined $sites_line ) { $self->throw("Out of sync: $score_file vs $sites_file"); }
        chomp($score_line);
        my @items = split(/\t/,$sites_line);
        print $fh $score_line."\t".$items[2]."\t".$items[3];        # score,class,is_ts
        print $gz $items[0]."\t".$items[1]."\t".$score_line."\n";   # chr,pos,score
        if ( $items[2] eq $$self{good_site} ) { $ngood_sites++; }
        $ntot_sites++;
    }
    close($fh) or $self->throw("close failed: sort -k1,1gr > $outfile.tmp");
    close($gz) or $self->throw("close failed: bgzip -c > $outfile.sites.gz");
    close($score_fh) or $self->throw("close failed: $score_file");
    close($sites_fh) or $self->throw("close failed: gunzip -c $sites_file");
    $self->cmd("tabix -s1 -b2 -e2 $outfile.sites.gz");

    open($fh,'<',"$outfile.tmp") or $self->throw("$outfile.tmp: $!");
    open(my $out,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $out "# [1]Sensitivity\t[2]Number of sites\t[3]Number of novel sites\t[4]Ts/Tv\t[5]Novel Ts/Tv\t[6]Score threshold\n";
    my $ngood = 0;
    my $ntot  = 0;
    my $nts   = 0;
    my $ntv   = 0;
    my $nts_novel = 0;
    my $ntv_novel = 0;
    my $ntot_prev = 0;
    my $score_prev;
    while (my $line=<$fh>)
    {
        my ($score,$class,$is_ts) = split(/\t/,$line);
        chomp($is_ts);
        if ( $class ne $$self{bad_site} )
        {
            if ( $is_ts )
            {
                $nts++; 
                if ( $class ne $$self{good_site} ) { $nts_novel++; }
            }
            else 
            { 
                $ntv++; 
                if ( $class ne $$self{good_site} ) { $ntv_novel++; }
            }
            $ntot++;
            if ( $class eq $$self{good_site} ) { $ngood++; }
        }
        if ( !defined $score_prev ) { $score_prev = $score; }
        if ( $score_prev eq $score ) { next; }
        $score_prev = $score;

        if ( ($ntot-$ntot_prev)/$ntot_sites < 0.001 ) { next; }
        $ntot_prev = $ntot;
        printf $out "%.2f\t%d\t%d\t%.3f\t%.3f\t$score_prev\n", 100.*$ngood/$ngood_sites, $ntot, $nts_novel+$ntv_novel, $ntv?$nts/$ntv:0,$ntv_novel?$nts_novel/$ntv_novel:0;
    }
    printf $out "%.2f\t%d\t%d\t%.3f\t%.3f\t$score_prev\n", 100.*$ngood/$ngood_sites, $ntot, $nts_novel+$ntv_novel, $ntv?$nts/$ntv:0,$ntv_novel?$nts_novel/$ntv_novel:0;
    close($out) or $self->throw("close failed: $outfile.part");
    close($fh) or $self->throw("close failed: $outfile.tmp");
    unlink("$outfile.tmp");

    $self->plot_tstv_graph($outfile);
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub plot_tstv_graph
{
    my ($self,$outfile) = @_;
    open(my $fh,'>',"$outfile.py") or $self->throw("$outfile.py: $!");
    $self->tprint($fh,"
            import matplotlib as mpl
            mpl.use('Agg')
            import matplotlib.pyplot as plt

            import os
            file = '$outfile'
            if not os.access(file, os.R_OK): file = '$outfile.part'

            import csv
            csv.register_dialect('tab', delimiter='\\t', quoting=csv.QUOTE_NONE)
            dat = []
            with open(file, 'rb') as f:
            \\treader = csv.reader(f, 'tab')
            \\tfor row in reader:
            \\t\\tif row[0][0]!='#': dat.append(row)

            max_sens = max([float(x[0]) for x in dat])
            min_sens = max_sens - 15

            fig, ax1 = plt.subplots(1,1, figsize=(5,4))
            ax2 = ax1.twinx()
            plots  = ax1.plot([x[1] for x in dat],[x[3] for x in dat],'g',label='Ts/Tv')
            plots += ax1.plot([x[1] for x in dat],[x[4] for x in dat],'r',label='Novel Ts/Tv')
            plots += ax2.plot([x[1] for x in dat],[x[0] for x in dat],'k',label='Sensitivity')
            labels = [l.get_label() for l in plots]
            plt.legend(plots,labels,numpoints=1,markerscale=2,loc='best',prop={'size':9},frameon=False)
            ax1.set_ylabel('Ts/Tv')
            ax1.set_xlabel('Number of sites')
            ax2.set_ylabel('Sensitivity')
            ax1.ticklabel_format(style='sci', scilimits=(-3,2), axis='x')
            ax2.set_ylim(min_sens,max_sens)
            plt.subplots_adjust(left=0.15,right=0.87,bottom=0.12,top=0.9)
            plt.savefig('$outfile.png')
            plt.close()
            ");
    close($fh) or $self->throw("close failed: $outfile.py");
    $self->cmd("python $outfile.py");
}

sub classify_merge
{
    my ($self,$outfile,@files) = @_;
    my %dat = ();
    for my $file (@files)
    {
        open(my $fh,'<',$file) or $self->throw("$file: $!");
        my $prev = 0;
        while (my $line=<$fh>)
        {
            if ( $line=~/^#/ ) { next; }
            my @vals = split(/\t/,$line);
            my $sens = $vals[0]==100 ? "100.001" : sprintf "%.1f", $vals[0];     # this small hack is to ensure that the last value is always present
            if ( $sens eq $prev ) { next; }
            chomp($vals[-1]);
            $prev   = $sens;
            my $ts  = $vals[3]*$vals[1]/($vals[3]+1);
            my $tv  = $vals[1]/($vals[3]+1);
            my $nts = $vals[4]*$vals[2]/($vals[4]+1);
            my $ntv = $vals[2]/($vals[4]+1);
            $dat{$sens}{ts}  += $ts;
            $dat{$sens}{tv}  += $tv;
            $dat{$sens}{nts} += $nts;
            $dat{$sens}{ntv} += $ntv;
            push @{$dat{$sens}{scores}}, $vals[5];
        }
        close($fh) or $self->throw("close failed: $file");
    }
    open(my $fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $fh "# [1]Sensitivity\t[2]Number of sites\t[3]Number of novel sites\t[4]Ts/Tv\t[5]Novel Ts/Tv\t[6]Score thresholds\n";
    for my $file (@files) { print $fh "# $file\n"; }
    for my $sens (sort {$a<=>$b} keys %dat)
    {
        if ( scalar @{$dat{$sens}{scores}} != scalar @files ) { next; }
        printf $fh "%.1f\t%d\t%d\t%.3f\t%.3f\t%s\n", $sens,
            $dat{$sens}{ts}+$dat{$sens}{tv}, 
            $dat{$sens}{nts}+$dat{$sens}{ntv}, 
            $dat{$sens}{tv}?$dat{$sens}{ts}/$dat{$sens}{tv}:0, 
            $dat{$sens}{ntv}?$dat{$sens}{nts}/$dat{$sens}{ntv}:0,
            join(',',@{$dat{$sens}{scores}});
    }
    close($fh) or $self->throw("close failed: $outfile.part");

    $self->plot_tstv_graph($outfile);
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub annotate_scores
{
    my ($self,$outfile,$infile, @files) = @_;
    if ( scalar @files !=1 ) { $self->throw("todo: ", join(' ',@files), "\n"); }
    my $ann_fname = $files[0] . ".sites.gz";

    open(my $fh,'>',"$outfile.hdr") or $self->throw("$outfile.hdr: $!");
    print $fh qq[##INFO=<ID=MLQ,Number=1,Type=Float,Description="Machine Learning Quality Score">\n];
    close($fh) or $self->throw("close failed: $outfile.hdr");

    $self->cmd("$$self{bcftools} view $infile | $$self{bcftools} annotate -a $ann_fname -h $outfile.hdr -c CHROM,FROM,MLQ -Oz > $outfile.part");
    unlink("$outfile.hdr");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub tprint
{
    my ($self,$fh,@txt) = @_;
    for my $txt (@txt)
    {
        $txt =~ s/\n[ \t]+/\n/g;
        $txt =~ s/\\t/\t/g;
        $txt =~ s/\n\\t\s*/\n\t/g;
        print $fh $txt;
    }
}

sub mrProper
{
    my ($self,$outdir) = @_;
    $self->clean($outdir);
}

sub clean
{
    my ($self,$outdir) = @_;
    $self->SUPER::clean($outdir);
}

sub runtime_stats
{
    my ($self,$outfile) = @_;
    $self->cmd("mkdir -p $outfile.part");
    $self->cmd("runtime-stats $$self{outdir} -p $outfile.part/graph > $outfile.part/stats.txt");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub save_config
{
    my ($self) = @_;
    my $src  = $$self{_config};
    my $type = ref($self) eq 'SOM_Runner' ? 'som' : 'svm';
    my $dst  = "$$self{outdir}/$type-filter.conf";
    if ( -e $dst && (stat($src))[9] <= (stat($dst))[9] ) { return; }
    if ( !-d $$self{outdir} ) { $self->cmd("mkdir -p $$self{outdir}"); }
    open(my $fh,'>',$dst) or $self->throw("$dst: $!");
    my $about = $$self{_about};
    $about =~ s/\n/\n# /g;
    print $fh "# $about";
    close($fh);
    $self->cmd("cat $src >> $dst");
}

sub tabix_part
{
    my ($self,$vcf) = @_;
    if ( $vcf=~/\.vcf.gz$/ )
    {
        $self->cmd("$$self{bcftools} tabix -p vcf -f $vcf.part");
        rename("$vcf.part.tbi","$vcf.tbi");
    }
    else
    {
        $self->cmd("$$self{bcftools} index $vcf.part");
        rename("$vcf.part.csi","$vcf.csi");
    }
    rename("$vcf.part",$vcf);
}

sub read_value
{
    my ($self,$file,$re_delim,$nrow,$ncol) = @_;
    open(my $fh,'<',$file) or $self->throw("$file: $!");
    for (my $i=0; $i<$nrow; $i++) { <$fh>; }
    my $line = <$fh>;
    close($fh) or $self->throw("close failed: $file");
    my @items = split($re_delim,$line);
    if ( defined $ncol ) 
    {
        chomp($items[$ncol]);
        return $items[$ncol];
    }
    return (@items);
}

sub expand_train_args
{
    my ($self,$args) = @_;
    return $args;
}

sub strip_cmdline_args
{
    my ($self,$args,@params) = @_;
    for my $param (@params)
    {
        $args =~ s/$param\s*\S+/ /s;
    }
    return $args;
}

#-------------------------------------------------------------------------------------------------

package SVM_Runner;
use base qw(myRunner);
use strict;
use warnings;

sub SVM_Runner::new
{
    my ($class,@args) = @_;
    my $self = {@args};
    bless $self, ref($class) || $class;

    $$self{bcftools}     = 'bcftools';
    $$self{plot_stats}   = 'plot-vcfstats';
    $$self{svm_train}    = '/nfs/users/nfs_p/pd3/sandbox/svn/svm/libsvm-3.17/svm-train';
    $$self{svm_predict}  = '/nfs/users/nfs_p/pd3/sandbox/svn/svm/libsvm-3.17/svm-predict';
    $$self{apar}  = [-5,15,2];
    $$self{bpar}  = [-15,3,2];
    $$self{aopt}  = 'c';
    $$self{bopt}  = 'g';
    $$self{snps}{train_args} = '-b 1 -c 15 -g -3';
    $$self{nfold}            = '-v 5';
    $$self{_sampleconf}  = q[
            # ------------------------------------
            # SVM-specific parameters 
            # ------------------------------------

            bcftools     => '] .$$self{bcftools}. q[',
            plot_stats   => '] .$$self{plot_stats}. q[',
            svm_train    => '] .$$self{svm_train}. q[',
            svm_predict  => '] .$$self{svm_predict}. q[',

            # SVM C and gamma parameters scan: min,max,step (2**c,2**g)
            apar => \[] .join(',',@{$$self{apar}}). q[\],  # c
            bpar => \[] .join(',',@{$$self{bpar}}). q[\],  # g
            aopt => '] .$$self{aopt}. q[',
            bopt => '] .$$self{bopt}. q[',
    ];

    return $self;
}

sub SVM_Runner::main
{
    my ($self) = @_;
    $self->parse_args();
    $self->save_config();
    $self->SUPER::main();
}

sub SVM_Runner::expand_train_args
{
    my ($self,$args) = @_;
    my @args = split(/\s+/,$args);
    for (my $i=0; $i<@args; $i++)
    {
        if ( $args[$i] eq '-c' ) { $i++; $args[$i] = 2**$args[$i]; }
        if ( $args[$i] eq '-g' ) { $i++; $args[$i] = 2**$args[$i]; }
    }
    return join(' ',@args);
}

sub SVM_Runner::format_values
{
    my ($self,$anns,@vals) = @_;
    my @out;
    for (my $i=0; $i<@vals; $i++)
    {
        my $val = $vals[$i];
        if ( !defined $val ) { next; }
        push @out, ($i+1).':'.$val;
    }
    return (@out);
}

sub SVM_Runner::strip_values
{
    my ($self,$keep,@vals) = @_;
    my @out;
    for my $rec (@vals)
    { 
        my ($idx,$val) = split(/:/,$rec);
        if ( !exists($$keep{$idx-1}) ) { next; }
        push @out, $rec;
    }
    return (@out);
}

sub SVM_Runner::train
{
    my ($self,$file,$args) = @_;
    $args = $self->expand_train_args($args);
    my @ret = $self->cmd("$$self{svm_train} $$self{nfold} $args $file");
    if ( !($ret[-1]=~/^Cross Validation Accuracy = ([\d.]+)/) ) 
    { 
        $self->throw("Could not parse the output of $$self{svm_train} $args $file: $ret[-1]"); 
    }
    return $1;
}

sub SVM_Runner::scan_params_jobs
{
    my ($self,$type,$job) = @_;
    my @jobs = ();
    my $args = $self->strip_cmdline_args($$self{$type}{train_args}, "-$$self{aopt}", "-$$self{bopt}");
    for (my $apar=$$self{apar}[0]; $apar<=$$self{apar}[1]; $apar+=$$self{apar}[2])
    {
        for (my $bpar=$$self{bpar}[0]; $bpar<=$$self{bpar}[1]; $bpar+=$$self{bpar}[2])
        {
            my $aval = 2**$apar;
            my $bval = 2**$bpar;
            my $a = $$self{aopt}.' '.$aval;
            my $b = $$self{bopt}.' '.$bval;
            push @jobs, { prefix=>"scan-$$self{aopt}$apar-$$self{bopt}$bpar", args=>"$args -$a -$b", apar=>$apar, bpar=>$bpar };
        }
    }
    return (@jobs);
}

sub SVM_Runner::scan_params_test
{
    my ($self,$outfile,$train_fname,$args) = @_;
    my @ret = $self->cmd("$$self{svm_train} $$self{nfold} $args $train_fname");
    if ( !($ret[-1]=~/^Cross Validation Accuracy = ([\d.]+)/) ) { $self->throw("Could not parse output of $$self{bcftools} som --train $train_fname $args: $ret[0]\n"); }
    open(my $fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $fh $1, "\n";
    close($fh) or $self->throw("close failed: $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub SVM_Runner::classify
{
    my ($self,$outfile,$train_fname,$annots_fname,$train_args) = @_;
    $self->cmd("mkdir -p $outfile.part");
    $self->cmd("$$self{svm_train} -b 1 $train_args $train_fname $outfile.part/model");
    $self->cmd("$$self{svm_predict} -b 1 $annots_fname $outfile.part/model $outfile.part/out.tab");
    open(my $fh,'<',"$outfile.part/out.tab") or $self->throw("$outfile.part/out.tab: $!");
    open(my $out,'>',"$outfile.part/scores.tab") or $self->throw("$outfile.part/scores.tab: $!");
    my $line = <$fh>; 
    my @items = split(/\s+/,$line); chomp($items[-1]);
    my $idx;
    for (my $i=0; $i<@items; $i++) { if ($items[$i] eq $$self{good_site}) { $idx=$i; } }
    if ( !defined $idx ) { $self->throw("Could not parse: $outfile.part/out.tab"); }
    while ($line=<$fh>)
    {
        my @vals = split(/\s+/,$line);
        chomp($vals[$idx]);
        print $out $vals[$idx]."\n";
    }
    close($out) or $self->throw("close failed: $outfile.part/scores.tab");
    close($fh) or $self->throw("close failed: $outfile.part/out.tab");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

#-------------------------------------------------------------------------------------------------

package SOM_Runner;
use base qw(myRunner);
use strict;
use warnings;

sub SOM_Runner::new
{
    my ($class,@args) = @_;
    my $self = {@args};
    bless $self, ref($class) || $class;

    $$self{bcftools}     = 'bcftools';
    $$self{plot_stats}   = 'plot-vcfstats';
    $$self{apar}         = [0.1,1.2,0.1];
    $$self{bpar}         = [20,50,5];
    $$self{aopt}         = 'l';
    $$self{bopt}         = 's';
    $$self{snps}{train_args}  = '';
    $$self{nfold}             = '-f5';
    $$self{ngood_max}    = 10_000;
    $$self{nbad_max}     = 10_000;
    $$self{_sampleconf}  = q[
            # ------------------------------------
            # SOM-specific parameters 
            # ------------------------------------

            bcftools     => '] .$$self{bcftools}. q[',
            plot_stats   => '] .$$self{plot_stats}. q[',

            # Parameters scan: min,max,step
            apar => \[] .join(',',@{$$self{apar}}). q[\],  # c
            bpar => \[] .join(',',@{$$self{bpar}}). q[\],  # g
            aopt => '] .$$self{aopt}. q[',
            bopt => '] .$$self{bopt}. q[',

            # SOM cannot handle missing values, these defaults will be used instead
            defaults =>
            {
                RPB  => 1,
                SGB  => 0,
                VDB  => 1,
                QUAL => 999,
                MQSB => 1,
                ICB  => 1,

                MQB   => 1,
                BQB   => 1,
                MQSB  => 1,
                RPB2  => 1,
                MQB2  => 1,
                BQB2  => 1,
                MQSB2 => 1,
                MQ0F  => 0,
            },
    ] . $$self{_sampleconf};

    return $self;
}

sub SOM_Runner::main
{
    my ($self) = @_;
    $self->parse_args();
    $self->save_config();
    $self->SUPER::main();
}

sub SOM_Runner::format_values
{
    my ($self,$anns,@vals) = @_;
    my @out;
    for (my $i=0; $i<@vals; $i++)
    {
        my $val = $vals[$i];
        if ( !defined $val ) 
        { 
            if ( !defined $$self{defaults}{$$anns[$i]} ) { $self->throw("No default set for $$anns[$i]?"); }
            push @out, $$self{defaults}{$$anns[$i]}; 
        }
        else { push @out, $val; }
    }
    return (@out);
}

sub SOM_Runner::strip_values
{
    my ($self,$keep,@vals) = @_;
    my @out;
    for (my $i=0; $i<@vals; $i++)
    { 
        if ( !exists($$keep{$i}) ) { next; }
        push @out, $vals[$i];
    }
    return (@out);
}

sub SOM_Runner::train
{
    my ($self,$file,$args) = @_;
    my @ret = $self->cmd("$$self{bcftools} som --train $$self{nfold} $args $file");
    if ( !($ret[0]=~/^([\d.]+)/) ) { $self->throw("Could not parse output of $$self{bcftools} som $args --train $file: $ret[0]\n"); }
    return 100-$1;
}

sub SOM_Runner::scan_params_jobs
{
    my ($self,$type,$job) = @_;
    my @jobs  = ();
    my $args = $self->strip_cmdline_args($$self{$type}{train_args}, "-$$self{aopt}", "-$$self{bopt}");
    for (my $apar=$$self{apar}[0]; $apar<=$$self{apar}[1]; $apar+=$$self{apar}[2])
    {
        for (my $bpar=$$self{bpar}[0]; $bpar<=$$self{bpar}[1]; $bpar+=$$self{bpar}[2])
        {
            my $a = $$self{aopt}.$apar;
            my $b = $$self{bopt}.$bpar;
            push @jobs, { prefix=>"scan-$a-$b", args=>"$args -$a -$b", apar=>$apar, bpar=>$bpar };
        }
    }
    return (@jobs);
}

sub SOM_Runner::scan_params_test
{
    my ($self,$outfile,$train_fname,$args) = @_;
    my @ret = $self->cmd("$$self{bcftools} som --train $$self{nfold} $train_fname $args");
    if ( !($ret[0]=~/^([\d.]+)/) ) { $self->throw("Could not parse output of $$self{bcftools} som --train $train_fname $args: $ret[0]\n"); }
    open(my $fh,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    print $fh 100-$1, "\n";
    close($fh) or $self->throw("close failed: $outfile.part");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

sub SOM_Runner::classify
{
    my ($self,$outfile,$train_fname,$annots_fname,$train_args) = @_;
    $self->cmd("mkdir -p $outfile.part");
    $self->cmd("$$self{bcftools} som --train $$self{nfold} $train_args $train_fname -p $outfile.part/classify > $outfile.part/out.log");
    $self->cmd("$$self{bcftools} som --classify $annots_fname -p $outfile.part/classify > $outfile.part/scores.tab");
    my $i = 0;
    while ( -e "$outfile.part/classify.$i.py" ) { $self->cmd("python $outfile.part/classify.$i.py"); }
    $self->cmd("python $outfile.part/classify.eval.py");
    rename("$outfile.part",$outfile) or $self->throw("rename: $outfile.part $outfile");
}

