#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#
# This script/pipeline is intended for chaining multiple runners. It runs as a
# daemon and waits for new projects to appear in dropbox directory ("input_dir").
# The projects are small text files which define the input data, such as:
#
#   # Where to send notification about job completion
#   email: someone@somewhere.org
#
#   # Input file
#   vcf:  /path/to/input/file
#
#   # Maximum number of jobs to run simultaneously
#   maxjobs: 200
#
#   # List of chromosomes to include
#   region: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X
#
# Any config file values given as "$(var_name)" can be overriden.
#
# After the runners finish, the result is moved to output directory and an
# email is sent to notify the user.
#

use strict;
use warnings;
use Carp;

my $opts = parse_params();

create_lock($opts);
while (1)
{
    my $projects = list_projects($opts);
    for my $project (@$projects)
    {
        run_project($opts,$project);
    }
    if ( !$$opts{loop} ) { last; }
    print STDERR "sleeping..\n" unless !$$opts{verbose};
    sleep($$opts{loop});
}
remove_lock($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    print 
        "Usage: run-runners [OPTIONS]\n",
        "Options:\n",
        "   -c, --config <file>     config file\n",
        "   -l, --loop <int>        run in daemon mode, check the status every <int> seconds\n",
        "   -L, --lock <file>       exit if another instance is already running\n",
        "   -n, --nmax <int>        maximum number of projects to run simultaneously\n",
        "   -v, --verbose           print what's been done\n",
        "   -h, -?, --help          this help message\n",
        "\n";
    exit -1;
}

sub parse_params
{
    my $opts = { nmax_projects=>1 };
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-n' || $arg eq '--nmax' ) { $$opts{nmax_projects}=shift(@ARGV); next }
        if ( $arg eq '-L' || $arg eq '--lock' ) { $$opts{lock}=shift(@ARGV); next }
        if ( $arg eq '-l' || $arg eq '--loop' ) { $$opts{loop}=shift(@ARGV); next }
        if ( $arg eq '-c' || $arg eq '--config' ) { $$opts{config}=shift(@ARGV); next }
        if ( $arg eq '-v' || $arg eq '--verbose' ) { $$opts{verbose}=1; next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{config}) ) { error("Missing the -c option.\n") }
    my %x = do "$$opts{config}";
    if ( $@ ) { error("do $$opts{config}: $@\n"); }
    %$opts = (%$opts,%x);
    return $opts;
}

sub create_lock
{
    my ($opts) = @_;

    if ( !exists($$opts{lock}) ) { return; }

    my $lock = $$opts{lock};
    if ( -e $lock )
    {
        # Find out the PID of the running pipeline
        open(my $fh,'<',$lock) or error("$lock; $!");
        while (my $pid=<$fh>)
        {
            chomp($pid);
            if ( !($pid=~/^\d+$/) ) { die "Could not parse lock file: $lock, $pid\n"; }

            # Is the process still running?
            my $running = kill 0, $pid;
            if ( $running )
            {
                my @out = `ps --no-headers -p $pid -o command`;
                my $script_name = $0;
                $script_name =~ s{^.*/}{};
                if ( $out[0]=~/$script_name/ )
                {
                    die "Another process is running ($pid), exiting.\n";
                }
            }

            print STDERR "Ignoring an old lock file, PID $pid is not running.\n";
            last;
        }
        close($fh);
    }

    open(my $fh,'>',$lock) or error("$lock: $!");
    print $fh $$ . "\n";
    close($fh);
}

sub remove_lock
{
    my ($opts) = @_;
    if ( !exists($$opts{lock}) ) { return; }
    my $lock = $$opts{lock};
    if ( -e $lock ) { unlink($lock); }
}

sub list_projects
{
    my ($opts) = @_;
    my @projects = ();

    # First check projects in progress
    my ($dh,$project);
    opendir($dh, $$opts{work_dir}) or error("$$opts{work_dir}: $!");
    while (my $dir = readdir($dh))
    {
        if ( !-d "$$opts{work_dir}/$dir" or !($dir=~/^\d+_(.*)$/ ) ) { next; }
        $project = parse_project($opts,"$$opts{work_dir}/$dir/$1.txt");
        push @projects, $project;
        if ( scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    if ( scalar @projects >= $$opts{nmax_projects} ) { return \@projects; }


    # No unfinished projects, check for new
    opendir($dh, $$opts{input_dir}) or error("$$opts{input_dir}: $!");
    while (my $file = readdir($dh))
    {
        if ( !($file =~/\.txt$/ ) ) { next; }
        $project = parse_project($opts,"$$opts{input_dir}/$file");
        my $alias = $$project{name};
        $alias =~ s/\.txt$//;
        $$project{alias} = time() .'_'. $alias;
        $$project{file}  = $file;

        system("mkdir -p $$opts{work_dir}/$$project{alias}");
        system("mv $$opts{input_dir}/$$project{file} $$opts{work_dir}/$$project{alias}/");
        if ( $? ) { confess "mv $$opts{input_dir}/$$project{file} $$opts{work_dir}/$$project{alias}/"; }

        push @projects, $project;
        if ( scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    return \@projects;
}

sub clean_project
{
    my ($opts,$project) = @_;

    my $name = $$project{name};
    debug_msg($opts,"Cleaning project: $name\n");
    $name =~ s/\.txt$//;
    $$project{prefix} = "$$opts{work_dir}/$$project{alias}/$name";

    for my $outdir (keys %{$$opts{outputs}})
    {
        system("mkdir -p $$opts{output_dir}/$$project{alias}/$outdir");
        for my $file (@{$$opts{outputs}{$outdir}})
        {
            my $path = expand_vars($opts,$project,$file);
            system("mv $path $$opts{output_dir}/$$project{alias}/$outdir/");
        }
    }

    system("mkdir -p $$opts{output_dir}/$$project{alias}/tmp-data");
    system("mv $$opts{work_dir}/$$project{alias} $$opts{output_dir}/$$project{alias}/tmp-data");
}

# Parse the project definition
sub parse_project
{
    my ($opts,$file) = @_;
    if ( !($file=~m{^(.+)/([^/]+)$}) ) { error("Could not parse dir/fname: $file\n"); }
    my $dir  = $1;
    my $name = $2;
    my %project = ();
    open(my $fh,'<',$file) or error("$file: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/^#/ ) { next; }
        if ( $line=~/^\s*$/ ) { next; }
        $line =~ s/^\s*//;
        $line =~ s/\s*$//;
        if ( !($line=~/^\s*([^:]+)\s*:/) ) { error("Could not parse $file: $line\n"); }
        my $key = $1;
        my $value = $';
        $value =~ s/^\s*//;
        $value =~ s/\s*$//;
        $key   =~ s/\s*$//;
        $key   =~ s{[^A-Za-z0-9\-\.\+_\{\}/\@]+}{}g;     # any key can be modified, no malicious code please
        $value =~ s{[^A-Za-z0-9\-\.\+_\{\}/\@]+}{}g;
        $project{$key} = $value;
    }
    close($fh) or error("close failed: $file");
    $project{dir}  = $dir;
    $project{name} = $name;
    if ( $dir=~m{^.+/(\d+_[^/]+)$} ) { $project{alias} = $1; }
    return \%project;
}

# Replace variables $(var_name)
sub expand_vars
{
    my ($opts,$project,$str) = @_;
    pos($str) = 0;
    while ( ($str =~ /\G(.*?)\$\(([^\)]+)\)/s) )
    {
        pos($str) += length($&);
        if ( exists($$project{$2}) ) 
        { 
            $str = $` . $1 . $$project{$2} . $'; 
            next; 
        }
        if ( exists($$opts{$2}) )
        { 
            $str = $` . $1 . $$opts{$2} . $'; 
            next; 
        }
    }
    return $str;
}

sub first_file_newer
{
    my ($a,$b) = @_;
    my $atime = (stat($a))[9];
    my $btime = (stat($b))[9];
    return $atime > $btime ? 1 : 0;
}

sub debug_msg
{
    my ($opts,@msg) = @_;
    if ( !$$opts{verbose} ) { return; }
    print STDERR join('',@msg);
}

# Create config file for each task (if the key "config" exists for the task)
# and run all runners until finished.
sub run_project
{
    my ($opts,$project) = @_;
    my $name = $$project{name};
    debug_msg($opts,"Checking status: $name\n");
    $name =~ s/\.txt$//;
    for my $task (@{$$opts{tasks}})
    {
        my $prefix = "$$opts{work_dir}/$$project{alias}/$name";
        debug_msg($opts, "Checking task: $prefix.$task.done\n");
        if ( -e "$prefix.$task.done" ) 
        { 
            debug_msg($opts, "Task done: $prefix\n");
            next; 
        }
        if ( ! -e "$prefix.$task" ) { system("mkdir -p $prefix.$task"); }
        $$project{prefix} = $prefix;

        if ( exists($$opts{$task}{config}) && (!-e "$prefix.$task.conf" or first_file_newer($$opts{config},"$prefix.$task.conf")) )
        {
            my $config = expand_vars($opts,$project,$$opts{$task}{config});
            open(my $fh,'>',"$prefix.$task.conf.part") or error("$prefix.$task.conf.part: $!");
            print $fh $config;
            close($fh) or error("close failed: $prefix.$task.conf.part");
            rename("$prefix.$task.conf.part","$prefix.$task.conf") or error("rename $prefix.$task.conf.part $prefix.$task.conf: $!");
        }

        my $ret = run_task($opts,$project,$task);
        if ( !$ret ) { return; }

        system("touch $prefix.$task.done");
        if ( $? ) { confess "touch $prefix.$task.done"; }
    }
    clean_project($opts,$project);
    send_email($project,"The project \"$name\" finished","The project \"$name\" finished");
}


# Run a single runner
sub run_task
{
    my ($opts,$project,$task_name) = @_;
    my $task = $$opts{$task_name};
    for my $job (@{$$task{run}})
    {
        my $cmd = expand_vars($opts,$project,$$job{cmd});
        debug_msg($opts, "Running task: $cmd\n");

        while ( 1 )
        {
            print STDERR "$cmd\n";
            system($cmd);

            my $status = $? >> 8;

            if ( $status==$$job{status}{error} )
            {
                send_email($project,"$task_name failed","Project $$project{name} failed: $cmd");
                error("Failed: $cmd"); 
            }

            if ( $status==$$job{status}{done} ) 
            { 
                send_email($project,"$task_name done","Finished");
                last;
            }
            if ( !exists($$job{loop}) ) { last }

            if ( $status==$$job{status}{loop} )
            {
                if ( !$$opts{loop} ) { return 0; }
                sleep($$job{loop}); 
            }
            else 
            { 
                send_email($project,"$task_name error","Unexpected return status: status ($?): $cmd\nProject $$project{name}\n");
                error("Unexpected return status: $status ($?) .. $cmd"); 
            }
        }
    }
    return 1;
}

sub send_email
{
    my ($opts, $status, @msg) = @_;
    if ( !exists($$opts{email}) ) { return; }
    open(my $mh,"| mail -s 'Runner report: $status' $$opts{email}");
    print $mh join('',@msg) . "\n";
    close($mh);
}

